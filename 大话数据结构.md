# 大话数据结构

## 第一章 数据结构绪论

### 1.4 基本概念和术语

#### 1.4.1 数据

#### 1.4.2 数据元素

#### 1.4.3 数据项

#### 1.4.4 数据对象

#### 1.4.5 数据结构

### 1.5 逻辑结构与物理结构

#### 1.5.1 逻辑结构

1. 集合结构
2. 线性结构
3. 树形结构
4. 图形结构

#### 1.5.2 物理结构（存储结构）

1. 顺序存储结构
2. 链式存储结构

### 1.6 数据类型

#### 1.6.1 数据类型定义

#### 1.6.2 抽象数据类型

抽象数据类型(ADT): 一个数学模型及定义在该模型上的一组操作.

```ADT
ADT 抽象数据类型名
Data

Operation
    操作1
        初始条件
        操作结果描述
endADT
```

注: 本书中使用C语言实现数据类型,
 在ADT中, 改变数据类型本身的情况使用类似传址方式表示如 `*S`,
 不改变数据类型本身的情况使用类似传值方式表示如 `S`,
 但对于顺序存储结构实现, 传递参数时为保证效率, 不论是否改变数据类型本身一般都以传址方式实现,
 此时不改变数据类型本身的情况使用 `const` 限定,
 而对于链式存储结构与 ADT 中的表示相同

## 第二章 算法

### 2.4 算法定义

### 2.5 算法的特性

1. 输入输出
2. 有穷性
3. 确定性
4. 可行性

### 2.6 算法设计的要求

1. 正确性
2. 可读性
3. 健壮性
4. 时间效率高和存储量低

### 2.7 算法效率的度量方法

#### 2.7.1 事后统计方法

#### 2.7.2 事前分析估算方法

高级语言编写的程序运行时消耗的时间的影响因素：

1. **算法采用的策略、方法**
2. 编译产生的代码质量
3. **问题的输入规模**
4. 机器执行指令的速度

### 2.8 函数的渐近增长

判断一个函数的效率时，函数中的常数和其他次要项常常可以忽略，而应该关注主项（最高阶项）的项数

### 2.9 算法时间复杂度

#### 2.9.1 算法时间复杂度定义

$ T(n) = O(f(n)) $

#### 2.9.2 推导大O阶方法

#### 2.9.3 常数阶

#### 2.9.4 线性阶

#### 2.9.5 对数阶

#### 2.9.6 平方阶

### 2.10 常见的时间复杂度

$$
O(1) < O(\log{n}) < O(n\log{n}) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
$$

### 2.11 最坏情况与平均情况

一般计算最坏情况运行时间即**最坏时间复杂度**

平均运行时间代表了期望的运行时间即**平均时间复杂度**

### 2.12 算法空间复杂度

$ S(n) = O(f(n)) $

## 第三章 线性表

### 3.2 线性表的定义

> 线性表 (List): 零个或多个数据元素的有限序列。

### 3.3 线性表的抽象数据类型

```ADT
ADT 线性表 (List)
Data

Operation
    init_list(*L)
    list_empty(L)
    clear_list(*L)
    get_elem(L, i, *e)
    locate(L, e)
    list_insert(*L, i, e)
    list_delete(*L, i, *e)
    list_length(L)
endADT
```

计算集合 $ A = A \cup B $, 使用 `La` 表示集合 $ A $, `Lb` 表示集合 $ B $

```C
void union(sqList *La, sqList Lb)
{
    int La_len, Lb_len, i;
    ElemType e;
    La_len = list_length(*La);
    Lb_len = list_length(Lb);
    for (i = 1; i <= Lb_len; i++) {
        GetElem(Lb, i, &e);
        if (!locate_elem(*La, e))
            list_insert(La, ++La_len, e);
    }
}
```

### 3.4 线性表的顺序存储结构

#### 3.4.1 顺序存储定义

> 用一段连续的存储单元依次存储线性表的数据元素

#### 3.4.2 顺序存储方式

```C
#define MAXSIZE 20
typedef int elemType;
typedef struct {
    elemType data[MAXSIZE];
    int length;
} sqList;
```

#### 3.4.3 数组长度与线性表长度的区别

##### 数组长度

存放线性表的储存空间的长度，储存分配后一般不变。

##### 线性表长度

线性表中数据元素的个数，随插入和删除操作而发生变化

在任意时刻，线性表的长度小于等于数组的长度

#### 3.4.4 地址的计算方法

线性表的第 $ i $ 个元素存放在数组下标为 $ i - 1 $ 的位置

线性表中元素的储存位置之间的关系

$$ LOC(a_{i+1}) = LOC(a_{i}) + c $$

可推得

$$ LOC(a_{i}) = LOC(a_{1}) + (i - 1) * c $$

存取性能为 $ O(1) $ 称之为随机存取结构.

### 3.5 顺序存储结构的插入与删除

#### 3.5.1 获得元素操作

```C
#define OK 1
#define ERROR 0
typedef int status;
status get_elem(const sqList *L, int i, elemType *e)
{
    if (L->length == 0 || i < 1 || i > L->length)
        return ERROR;
    *e = L->data[i - 1];

    return OK;
}
```

#### 3.5.2 插入操作

```c
status list_insert(sqList *L, int i, elemType e)
{
    int k;

    if (L->length == MAXSIZE)
        return ERROR;
    if (i < 1 || i > L->length + 1)
        return ERROR;
    if (i <= L->length) {
        for (k = L->length - 1; k >= i - 1; --k)
            L->data[k + 1] = L->data[k];
    L->data[i - 1] = e;
    ++L->length;

    return OK;
    }
}
```

#### 3.5.3 删除操作

```c
status list_delete(sqList *L, int i, elemType *e)
{
    int k;

    if (L->length == 0)
        return ERROR;
    if (i < 1 || i > L->length + 1)
        return ERROR;
    *e = L->data[i - 1];
    if (i < L->length) {
        for (k = i; k < L->length; ++k)
            L->data[k - 1] = L->data[k];
    }
    --L->length;

    return OK;
}
```

插入和删除操作的时间复杂度分析

最好情况: 插入或者删除最后一个位置时为 $ O(1) $

最坏情况: 插入或者删除第一个位置时为 $ O(n) $

平均情况:

$$
\sum_{i = 1}^{n}\frac{1}{n}(n - i + 1) = \frac{n - 1}{2}
$$

故平均时间复杂度为 $ O(n) $

#### 3.5.4 线性表顺序存储结构的优缺点

- 优点
    - 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
    - 可以快速地存取表中任意位置的元素
- 缺点
    - 插入和删除操作需要移动大量的元素
    - 当线性表长度变化较大时, 难以确定存储空间的容量
    - 造成存储空间的碎片

### 3.6 线性表的链式存储结构

#### 3.6.1 顺序存储结构不足的解决办法

#### 3.6.2 线性表链式存储结构定义

- 结点
    - 数据域
    - 指针域

链式存储结构:
> n个结点链接成一个链表
> 头结点: 有的链表为方便操作, 会在第一个结点前附设一个结点, 头结点数据域内可以不储存任何数据
> 头指针: 无头结点时为链表中第一个结点的存储位置, 有头结点时为指向头结点的指针

#### 3.6.3 线性表链式存储结构代码描述

```c
typedef struct node {
    elemType data;
    struct node *next;
} node;
typedef struct node *linkList;
```

### 3.7 单链表的读取

```c
status get_elem(linkList L, int i, elemType *e)
{
    int j = 1;
    node *p = L->next;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR;
    *e = p->data;
    return OK;
}
```

最坏时间复杂度为 $ O(n) $

### 3.8 单链表的插入与删除

#### 3.8.1 单链表的插入

将结点 `s` 插入到 `p` 与 `p->next` 之间

```c
s->next = p->next;
p->next = s;
```

注意: 上述语句的顺序不可颠倒

```c
status list_insert(linkList *L, int i, elemType e)
{
    int j = 1;
    node *s;
    node *p = *L;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR;
    s = (linkList)malloc(sizeof(node));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}
```

#### 3.8.2 单链表的删除

```c
q = p->next;
p->next = q->next;
free(q);
```

代码如下

```c
status list_delete(linkList *L, int i, elemType *e)
{
    int j = 1;
    node *q;
    node *p = *L;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR;
    q = p->next;
    p->next = q->next;
    *e = q->data;
    free(q);
    return OK;
}
```

插入和删除的时间复杂度均为 $ O(n) $

但若需插入的结点 (或者此结点的前置结点) 的位置已知则时间复杂度为 $ O(1) $

### 3.9 单链表的整表创建

头插法

```c
void create_list_head(linkList *L, int n)
{
    node *p;
    int i;
    *L = (linkList)malloc(sizeof(node));
    (*L)->next = NULL;
    for (i = 0; i < n; ++i) {
        p = (linkList)malloc(sizeof(node));
        p->data = i;
        p->next = (*L)->next;
        (*L)->next = p;
    }
}
```

尾插法

```c
void create_list_tail(linkList *L, int n)
{
    node *p;
    node *r;
    int i;
    *L = (linkList)malloc(sizeof(node));
    r = *L;
    for (i = 0; i < n; ++i) {
        p = (linkList)malloc(sizeof(node));
        p->data = i;
        r->next = p;
        r = p;
    }
    r->next = NULL;
}
```

### 3.10 单链表的整表删除

```c
void clear_list(linkList *L)
{
    node *p, *q;
    p = (*L)->next;
    (*L)->next = NULL;
    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    return OK;
}
```

### 3.11 单链表结构与顺序存储结构的优缺点

### 3.12 静态链表

在早期的没有指针的编程语言中, 用数组描述链表

静态链表结构

```c
#define MAXSIZE 1000
#define HEAD (MAXSIZE - 1)

typedef struct {
    elemType data;
    int cur;
} component, staticLinkList[MAXSIZE];
```

创建静态链表

```c
status init_list(staticLinkList space)
{
    int i;
    for (i = 0; i < HEAD; ++i)
        space[i].cur = i + 1;
    space[HEAD].cur = 0;
    return OK;
}
```

#### 3.12.1 静态链表的插入

分配空闲的结点

```c
int malloc_SSL(staticLinkList space)
{
    int i = space[HEAD].cur;
    if (i)
        space[HEAD].cur = space[i].cur;
    return i;
}
```

静态链表的插入

```c
status list_insert(staticLinkList L, int i, elemType e)
{
    int j, k, l;

    if (i < 1 || i > list_length(L) + 1)
        return ERROR;
    j = malloc_SSL(L);
    if (j) {
        L[j].data = e;
        for (l = 0, k = HEAD; l < i - 1; ++l)
            k = L[k].cur;
        L[j].cur = L[k].cur;
        L[k].cur = j;
        return OK;
    }
}
```

#### 3.12.2 静态链表的删除

释放不使用的结点

```c
void free_SSL(staticLinkList space, int i)
{
    space[i].cur = space[0].cur;
    space[0].cur = i;
}
```

静态链表的删除

```c
status list_delete(staticLinkList L, int i, elemType *e)
{
    int j, k;

    if (i < 1 || i > list_length(L))
        return ERROR;
    for (k = HEAD, j = 0; j < i - 1; ++j)
        k = L[k].cur;
    j = L[k].cur;
    L[k].cur = L[j].cur;
    *e = L[j].data;
    free_SSL(L, j);
    return OK;
}
```

另有其他操作, 如list_length

```c
int list_length(staticLinkList L)
{
    int j = 0;
    int i = L[HEAD].cur;
    while (i) {
        i = L[i].cur;
        ++j;
    }
    return j;
}
```

#### 3.12.3 静态链表的优缺点

### 3.12 循环链表

单循环链表中为使得到最后一节点的时间复杂度为 $ O(1) $ 使用指向终端结点的尾指针 `rear` 代替头指针

查找头结点 `rear->next`

查找开始结点 `rear->next->next`

有头结点的循环链表判断是否为空表

```c
status list_empty(linkList rear) {
    return rear->next == rear;
}
```

合并两个循环链表

```c
void merge_cycle_list(linkList rearA, linkList rearB) {
    node *p, *q;

    p = rearA->next;
    rearA->next = rearB->next->next;
    q = rearB->next;
    rearB->next = p;
    free(q);
}
```

### 3.13 双向链表

在单链表中, 再设置一个指向前驱结点的指针域

```c
typedef struct dulNode {
    elemType data;
    struct dulNode *prior, *next;
} dulNode, dulLinkList;
```

双链表也可设置为循环双链表

有头结点的双链表判断是否为空表

```c
status list_empty(dulLinkList L) {
    return L->next == NULL;
}
```

有头结点的双循环链表判断是否为空表

```c
status list_empty(dulLinkList L) {
    return L->next == L;
}
```

双链表的插入 (s为待插入结点, 插入到p结点之后)

```c
s->prior = p;
s->next = p->next;
p->next->prior = s;
p->next = s;
```

1, 2的顺序可颠倒, 但是其他的顺序不可改变

双链表的删除

```c
p->prior->next = p->next;
p->next->prior = p->prior;
free(p);
```

## 第四章 栈与队列

### 4.2 栈的定义

#### 4.2.1 栈的定义

栈:
> 限定仅在表尾进行插入和删除操作的线性表, 又称为后进先出 (Last In First Out) 线性表, 简称LIFO结构
> 允许进行插入删除操作的一端 (表尾) 称为栈顶 (Top) , 另一端称为栈底 (Bottom)
> 栈的插入操作称为进栈 (Push)
> 栈的删除操作称为出栈 (Pop)

#### 4.2.2 进栈出栈的变化形式

### 4.3 栈的抽象数据类型

```ADT
ADT 栈 (Stack)
Data
    同线性表
Operation
    init_stack(*S)
    destroy_stack(*S)
    clear_stack(*S)
    stack_empty(S)
    get_top(S, *e)
    push(*S, e)
    pop(*S, *e)
    stack_length(S)
endADT
```

### 4.4 栈的顺序存储结构及实现

#### 4.4.1 栈的顺序储存结构

顺序栈:
> 顺序表的简化, 使用下标0的一端作栈底

顺序栈的结构定义

```c
typedef struct {
    elemType data[MAXSIZE];
    int top;
} sqStack;
```

顺序栈的栈空判定

```c
status stack_empty(const sqStack *S)
{
    if (S->top == -1) {
        return OK;
    } else {
        return ERROR;
    }
}
```

#### 4.4.2 进栈操作

顺序栈的进栈

```c
status push(sqStack *S, elemType e)
{
    if (S->top == MAXSIZE - 1) {
        return ERROR;
    }
    S->top++;
    S->data[S->top] = e;
    return OK;
}
```

#### 4.4.3 出栈操作

顺序栈的出栈

```c
status pop(sqStack *S, elemType *e)
{
    if (S->top == -1) {
        return ERROR;
    }
    *e = S->data[S->top];
    S->top--;
    return OK;
}
```

出栈入栈时间复杂度均为 $ O(1) $

### 4.5 两栈共享空间

### 4.6 栈的链式存储结构及实现

#### 4.6.1 栈的链式存储结构

链栈:
> 链表的简化, 表头作栈顶, 且一般不需要头结点

链栈的结构定义

```c
typedef struct node {
    elemType data;
    struct node *next;
} node, *linkStackPtr;

typedef struct {
    linkStackPtr top;
    int count;
} linkStack;
```

链栈的栈空判定

```c
status stack_empty(linkStack *S)
{
    if (S->top == NULL) {
        return OK;
    } else {
        return ERROR;
    }
}
```

#### 4.6.2 进栈操作

链栈的进栈

```c
status push(linkStack *S, elemType e)
{
    node *s = (node*)malloc(sizeof(node));

    s->data = e;
    s->next = S->top;
    S->top = s;
    S->count++;
    return OK;
}
```

#### 4.6.3 出栈操作

链栈的出栈

```c
status pop(linkStack *S, elemType *e)
{
    node *p = S->top;

    if (S->top == NULL) {
        return ERROR;
    }
    *e = p->data;
    S->top = p->next;
    free(p);
    S->count--;
    return OK;
}
```

出栈入栈时间复杂度均为 $ O(1) $

### 4.7 栈的作用

栈的引入简化了程序设计的问题, 划分了不同关注层次, 使得思考范围缩小, 更加聚焦于要解决的问题核心.

### 4.8 栈的应用--递归

#### 4.8.1 斐波那契数列的实现

迭代法

```c
int fibonacci_iter(int n)
{
    int i;
    int fibo[100];
    fibo[0] = 0;
    fibo[1] = 1;
    for (i = 2; i <= n; ++i) {
        fibo[i] = fibo[i - 1] + fibo[i - 2];
    }
    return fibo[n];
}
```

递归法

```c
int fibonacci_recu(int n)
{
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci_recu(n - 1) + fibonacci_recu(n - 2);
    }
}
```

#### 4.8.2 递归的定义

递归函数:
> 直接调用自己或者经过一系列调用语句间接调用自己的函数

递归过程中先进行前行的递归调用, 随后又以前行顺序的逆序进行退回, 退回过程中可能需要恢复前行过程中的某些数据以执行某些动作, 故编译器使用栈实现递归

在前行阶段, 每一层递归对应的函数的局部变量, 参数值, 返回地址都被压入栈中, 回退阶段依次弹出进行恢复

### 4.9 栈的应用--四则运算表达式求值

#### 4.9.1 后缀 (逆波兰) 表示法的定义

后缀表示法:
> 符号在要运算的数字后出现, 不需要使用括号和优先级限定运算顺序
> 对应的, 传统的标准四则运算表达式称为中缀表达式

#### 4.9.2 后缀表达式的计算结果

运算方法:

```Pseudocode
从左到右遍历后缀表达式,

    遇到数字则进栈;

    遇到运算符则将栈顶的两个数字弹栈, 第一个出栈的位于运算符右侧, 第二个出栈的位于运算符左侧, 完成相应运算后计算结果进栈,

直至遍历完成, 将最终结果弹栈.
```

#### 4.9.3 中缀表达式转后缀表达式

转换方法:

```pesudocode
从左到右遍历中缀表达式,

    遇到数字则输出;

    遇到左括号则进栈;

    遇到右括号则将栈中运算符依次出栈并输出, 直至遇到左括号将其仅出栈不输出;

    遇到运算符则判断其与栈顶运算符的优先级,

        如果为空栈或栈顶为左括号( 则直接入栈;

        如果当前运算符优先级高于栈顶运算符则当前运算符入栈;

        如果当前运算符优先级不高于 (<=) 栈顶运算符, 则将栈中元素出栈并输出, 继续将当前运算符同栈顶运算符进行下一次比较;

继续遍历中缀表达式, 最终遍历完成中缀表达式, 将剩余栈中运算符依次弹栈输出, 完成转化
```

运算符等级 (从高到低) :

\* /

\+ \-

### 4.10 队列的定义

队列:
> 限定仅在表尾进行插入, 仅在表头进行删除操作的线性表, 又称为先进先出 (First In First Out) 线性表, 简称FIFO结构
> 允许进行插入操作的一端 \(表尾\) 称为队尾, 允许进行删除操作的一端 \(表头\) 称为队头
> 队列的插入操作称为入队, 删除操作称为出队

### 4.11 队列的抽象数据类型

```ADT
ADT 队列 (Queue)
Data
    同线性表
Operation
    init_queue(*Q)
    destroy_queue(*Q)
    clear_queue(*Q)
    queue_empty(Q)
    get_head(Q, *e)
    enqueue(*Q, e)
    dequeue(*Q, *e)
    queue_length(Q)
endADT
```

### 4.12 循环队列

#### 4.12.1 队列顺序存储的不足

#### 4.12.2 循环队列的定义

`front`指向队头元素, `rear`指向队尾元素的下一个位置

队满条件 (使用`flag`, 使最大储存量为`MAXSIZE`):
` (rear + 1) % queueSize == front && flag == 1 `

队满条件 (不使用`flag`, 使最大储存量为`MAXSIZE - 1`):
` (rear + 1) % queueSize == front `

主要采用不使用`flag`的版本

队列长度:
` (rear - front + queueSize) % queueSize `

顺序存储结构代码:

```c
typedef struct {
    elemType data[MAXSIZE];
    int front;
    int rear;
} sqQueue;
```

初始化循环队列:

```c
status init_queue(sqQueue *Q)
{
    Q->front = 0;
    Q->rear = 0;
    return OK;
}
```

循环队列判空:

```c
int queue_empty(const sqQueue *Q)
{
    return Q->front == Q->rear;
}
```

循环队列判满:

```c
int queue_full(const sqQueue *Q)
{
    return (Q->rear + 1) % MAXSIZE == Q->front;
}
```

循环队列长度:

```c
int queue_length(const sqQueue *Q)
{
    return (Q->rear - Q->front + MAXSIZE) % MAXSIZE;
}
```

循环队列入列:

```c
status enqueue(sqQueue *Q, elemType e)
{
    if ((Q->rear + 1) % MAXSIZE == Q->front) {
        return ERROR;
    }
    Q->data[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXSIZE;
    return OK;
}
```

循环队列出列:

```c
status dequeue(sqQueue *Q, elemType *e)
{
    if (Q->front == Q->rear) {
        return ERROR;
    }
    *e = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;

    return OK;
}
```

出队入队时间复杂度均为 $ O(1) $

### 4.13 队列的链式存储结构及实现

链队列:
> 链表的简化, 且一般需要头结点, 头节点的 `next` 指针指向队头
> 空队列时, `front` 和 `rear` 均指向头结点

链队列的结构定义:

```c
typedef struct node {
    elemType data;
    struct node *next;
} node;
typedef node *queuePtr;

typedef struct {
    queuePtr front;
    queuePtr rear;
} linkQueue;
```

#### 4.13.1 入队操作

链队列的入队:

```c
status enqueue(linkQueue *Q, elemType e)
{
    queuePtr p = (queuePtr)malloc(sizeof(node));
    if (!p) {
        exit(OVERFLOW);
    }
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = p;
    return OK;
}
```

#### 4.13.2 出队操作

链队列的出队:

```c
status dequeue(linkQueue *Q, elemType *e)
{
    queuePtr p;
    if (Q->front == Q->rear) {
        return ERROR;
    }
    p = Q->front->next;
    *e = p->data;
    Q->front->next = p->next;
    if (Q->rear == p) {
        Q->rear = Q->front;
    }
    free(p);
    return OK;
}
```

## 第五章 串

### 5.2 串的定义

串:
> 由零个或多个字符组成的有限序列, 又叫字符串

空串:

子串与主串:

子串在主串中的位置:

### 5.3 串的比较

字符比较:
> 比较两字符的编码值 (ASCII, Unicode)

串相等:
> 串的长度和各个位置对应的字符都相等

串大小判断 (字典序) :

逐个比较两串 $ s $ 与 $ t $ 各个位置字符的大小, 当出现不同时, 字符小的对应的串小, 若直至某一串被遍历完未发现字符不同, 被遍历完成的串小 (长度短的字符串小), 都被遍历完成则两串相等

### 5.4 串的抽象数据类型

串的逻辑结构同线性表相似, 但所含元素和主要操作不同

```ADT
ADT 串 (string)
Data
    串中元素仅由字符组成, 相邻元素具有前驱和后继关系
Operation
    str_assign(*T, *chars)
    str_copy(*T, S)
    str_length(S)
    str_compare(S, T)
    str_concat(*T, S1, S2)
    sub_string(*Sub, S, pos, len)
    str_insert(*T, pos, S)
    str_delete(*T, pos, len)
    str_replace(*T, S, V)
    str_index(S, T, pos)
    clear_string(*S)
endADT
```

`str_index` 操作的实现

```c
int str_index(string S, string T, int pos)
{
    int n, m, i;
    string sub;

    if (pos > 0) {
        n = str_length(S);
        m = str_length(T);
        i = pos;
        while (i <= n - m + 1) {
            sub_string(sub, S, i, m);
            strncpy(sub, S + i - 1, m);
            if (str_compare(sub, T) != 0) {
                ++i;
            } else {
                return i;
            }
        }
    }

    return 0;
}
```

### 5.5 串的存储结构

#### 5.5.1 串的顺序存储结构

> 用一组地址连续的储存单元存储串中的字符序列

表示串长的方法:

1. 下标0处存串长, 字符从下标1处开始 (本书采用的方法)
2. 字符从下标0处开始, 在字符的末尾存储一 `"\0"` 表示字符串结束 (C语言采用的方法)

#### 5.5.2 串的链式存储结构

> 与链表相同, 但可以考虑每个结点内存放多个字符, 未占满的结点内用 `"\0"` 或其他字符补全

### 5.6 朴素的模式匹配算法

串的模式匹配:
> 定位子串的位置的操作, 子串又称模式串

只使用基本的数组操作完成 `str_index`, 假定串长存储于下标为0的位置中

```c
int str_index(string S, string T, int pos)
{
    int i = pos;
    int j = 1;

    while (i <= S[0] && j <= T[0]) {
        if (S[i] == T[j]) {
            ++i;
            ++j;
        } else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > T[0]) {
        return i - T[0];
    } else {
        return 0;
    }
}
```

对于C语言中的字符串, 最后一位为 `"\0"` , 对应的 `str_index` 算法

```c
int str_index_c(string S, string T, int pos)
{
    int i = pos;
    int j = 0;
    int len_T;

    while (T[++j] != '\0');
    len_T = j;
    while (S[i] != '\0' && T[j] != '\0') {
        if (S[i] == T[j]) {
            ++i;
            ++j;
        } else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (T[j] == '\0') {
        return i - len_T;
    } else {
        return 0;
    }
}
```

### 5.7 KMP模式匹配算法

#### 5.7.1 KMP模式匹配算法的原理

在查找前对子串进行分析达到如下的目的:

1. 通过子串中相等或不同的字符使得指向主串的游标 `i` 不需要回溯

2. 指向子串的游标 `j` 的变化则取决于 `j` 指向的子串当前字符之前的串的前后缀的相似程度, 使得部分情况下 `j` 的回溯减少

把子串 `T` 的各个位置 `j` 值对应的变化记为定义为数组 `next`, `next` 的长度与 `T` 串相同, 得到如下的函数定义
$$
next[j] = \begin{cases}
0, & j = 1 \\
MAX\{k | 1 \leq k < j, T_1T_2\cdots T_{k-1} = T_{j-k}T_{j-k+1}\cdots T_{j-1}\}, & \text{When the set is not empty} \\
1, & others
\end{cases}
$$

#### 5.7.2 `next` 数组值的推导

1. 令` next[1] = 0 `, ` next[2] = 1 `
2. 随后的各个字符计算当前字符之前的串的最大相同前后缀长度为 `n` , `next[j] = n + 1` , 如  `"ab"`为1, ` "abca" ` 为2, ` "ababa" ` 为4

#### 5.7.3 KMP模式匹配算法的实现

编码计算 `next` 数组

对于模式串的位置 `j + 1`, 有以下两种情况:
若 `p[k] == p[j]`, 则有 `next[j + 1] = next[j] + 1`;
若 `p[k] != p[j]`, 则令 `k = next[k]`, 若 `p[k] == p[j]`, `next[j + 1] = k + 1`, 否则重复此过程。

```c
void get_next(string T, int next[])
{
    int i, k;
    i = 1;          /* As the index of the next areray */
    k = 0;
    next[1] = 0;    /* begin of next is 0 */
    while (i < T[0]) {
        if (k == 0 || T[i] == T[k]) {
            ++i;
            ++k;
            next[i] = k;
        } else {
            k = next[k];
        }
    }
}
```

实现KMP算法

```c
int str_index_KMP(string S, string T, int pos)
{
    int i = pos;
    int j = 1;
    int next[255];

    get_next(T, next);
    while (i <= S[0] && j <= T[0]) {
        if (S[i] == T[j]) {
            ++i;
            ++j;
        } else {
            j = next[j];    /* Only change this line compare with str_index */
        }
    }
    if (j > T[0]) {
        return i - T[0];
    } else {
        return 0;
    }
}
```

若  `S` 的长度为 $n$, `T` 的长度为 $m$

`get_next`函数的时间复杂度为 $ O(m) $

` str_index_KMP `的 `while` 部分的时间复杂度为 $ O(n) $

总的时间复杂度为 $ O(n + m) $

#### 5.7.4 KMP模式匹配算法的改进

利用模式串内的相同字符, 进一步减少回溯次数

在 `get_next` 函数中, 若 `T[j] == T[next[j]]`, 则 `next[j] = next[next[j]]`

计算 `nextval` 数组

```c
void get_nextval(string T, int nextval[])
{
    int i, k;
    i = 1;          /* As the index of the next areray */
    k = 0;
    nextval[1] = 0; /* begin of next is 0 */
    while (i < T[0]) {
        if (k == 0 || T[i] == T[k]) {
            ++i;
            ++k;
            if (T[i] != T[k]) {
                nextval[i] = k;
            } else {
                nextval[i] = nextval[k];
            }
        } else {
            k = nextval[k];
        }
    }
}
```

如果需要进行查找, 将查找函数中的 `get_next` 替换为 `get_nextval` 即可

#### 5.7.5 nextval 数组值的推导

步骤:

先计算 `next` 数组, 随后从 `i = 1` 开始计算 `nextval` 数组

令模式串中 `i` 位置指向的字符 `T[i]` 为 $a$, `next[i]` 位置指向的字符 `T[next[i]]` 为 $b$

$a$ 的值与 $b$ 的值不同, 则 `nextval[i]` 为 `next[i]` 保持不变, 否则 `nextval[i]` 的值改为 $b$ 对应的 `nextval` 的值

即若 `T[i] != T[next[i]]`, 则 `nextval[i] = next[i]`, 否则 `nextval[i] = nextval[next[i]]`

## 第六章 树

### 6.2 树的定义

树:

> $ n ( n \ge 0 ) $ 个结点的有限集
>
> $ n = 0 $ 时称为空树
>
> 在任意一棵非空树中:
>
> 1. 有且仅有一个特定的称为根 (Root) 的结点
> 2. $ n > 1 $  时, 其余节点可分为 $ m (m > 0) $ 个互不相交的有限集 $ T_1, T_2, \cdots, T_n $ 其中每一个集合本身又是一棵树, 称为根的子树 (subtree)

注意:

1. $ n > 0 $ 时的根节点唯一
2. $ m > 0 $ 时, 子树的个数没有限制, 但一定互不相交

#### 6.2.1 结点的分类

结点由一个数据元素和若干指向其子树的分支组成

结点的度 (degree): 结点拥有的子树数

度为 0 的结点称为叶节点 (leaf) 或者终端结点

度不为 0 的结点称为非叶节点或者分支结点, 除根以外的分支结点又称内部节点

记度数为 $ n $ 的结点个数为 $ n_n $ 则一棵树中的结点满足如下关系
$$
\sum^{n}_{i = 1} i n_{i} + 1 = \sum^{n}_{i = 0} n_i
$$

树的度: 树内各结点的度的最大值

#### 6.2.2 结点间的关系

结点的子树的根称为结点的孩子 (child)

相反该结点称为其孩子的双亲 (parent) , 也称父结点

同一个双亲的孩子之间互称兄弟 (sibling)

结点的祖先是从该结点所经分支上所有的结点

一某结点为根的子树中的任一结点都称为其子孙

### 6.3 树的抽象数据类型

```ADT
ADT 树 (Tree)
Data
    树是由一个根节点和若干棵子树构成. 树中结点具有相同数据类型及层次关系
Operation
    init_tree(*T)
    destroy_tree(*T)
    create_tree(*T, definition)
    clear_tree(*T)
    tree_empty(T)
    tree_depth(T)
    root(T)
    value(T, cur_e)
    assign(T, cur_e, value)
    parent(T, cur_e)
    left_child(T, cur_e)
    right_sibling(T, cur_e)
    insert_child(*T, *p, i, c)
    delete_child(*T, *p, i)
    traverse_tree(T, visit())
endADT
```

### 6.4 树的存储结构

#### 6.4.1 双亲表示法

以一组连续空间存储树的结点, 在每个结点中附设一个指示器指示其双亲结点在数组中的位置, 故结点分为数据域和双亲域

```c
#define MAXSIZE 100

typedef struct PTNode {
    elemType data;
    int parent;
} PTNode;

typedef struct {
    PTNode nodes[MAXSIZE];
    int r;      /* index of root */
    int n;      /* number of nodes */
} PTree;
```

从节点计算其双亲结点的复杂度为 $ O(1) $, 但计算孩子结点需要遍历整个结构

为方便计算某结点的孩子结点可以选择增设长子域和右兄弟域

```c
/* enhanced PTree */
typedef struct PTNode {
    elemType data;
    int parent;
    int firstChild; /* choice */
    int rightSib;   /* choice */
} ePTNode;

typedef struct {
    ePTNode nodes[MAXSIZE];
    int r;      /* index of root */
    int n;      /* number of nodes */
} ePTree;
```

#### 6.4.2 孩子表示法

多重链表表示法

每个结点有多个指针域, 每个指针指向一棵子树的根节点

可选择的方案:

- 指针域的个数等于树的度
    缺点: 各结点度相差较大时浪费空间

- 每个结点的指针域等于其度, 并设一变量储存结点的度

    各个结点结构不同, 且要维护度数, 造成性能损耗

实际的方案*孩子表示法*:

将每个结点的孩子结点排列成单链表, 则 $ n $ 个结点即有 $ n $ 个单链表, 叶子结点的单链表为空, 随后将 $ n $ 个头结点组成顺序表

需要两个数据结构

1. 排成单链表的孩子结点
2. 组成表头数组的表头结点

```c
#define MAXSIZE 100

typedef struct cNode { /* child tree node */
    elemType data;
    struct cNode *next;
} cNode, *childPtr;

typedef struct {        /* head node */
    elemType data;
    childPtr firstChild;
}hBox;

typedef struct {
    hBox nodes[MAXSIZE];
    int r;      /* index of root */
    int n;      /* number of nodes */
} cTree;
```

孩子表示法可以较快查得结点的孩子, 但是查找结点双亲困难

可以在顺序表内增设双亲域加快寻找结点双亲的过程, 称为双亲孩子表示法

#### 6.4.3 孩子兄弟表示法

设有两个指针域, 指向结点的第一个孩子以及结点的右兄弟

```c
typedef struct csNode {
    elemType data;
    struct csNode *firstChild;
    struct csNode *rightSib;
} csNode, *csTree;
```

可以通过此方法将任何树简化为后文将讲的二叉树进行分析

### 6.5 二叉树的定义

二叉树:

> $ n ( n \ge 0 ) $ 个结点的有限集, 该集合或者为空集 (称为空二叉树), 或者由一个根节点和两棵互不相交的, 分别称为根节点的左子树和右子树的二叉树组成

#### 6.5.1 二叉树的特点

1. 每个结点最多有两棵子树, 故二叉树中不存在度大于 2 的结点, 二叉树的度最大为2
2. 左子树和右子树是有顺序的, 不可颠倒
3. 即使某结点仅有一棵子树, 也必须区分左子树和右子树

#### 6.5.2 特殊二叉树

##### 1. 斜树

所有结点都只有左子树的二叉树称左斜树; 所有结点都只有右子树的二叉树称右斜树; 二者统称为斜树

##### 2. 满二叉树

二叉树中, 所有分支结点都有左子树和右子树, 并且所有的叶子结点都在同一层上

满二叉树的特点:

1. 叶子结点都出现在最后一层
2. 非叶子节点的度必定为2
3. 同样深度的二叉树中, 满二叉树的结点个数最多, 叶子结点的个数也最多

##### 3. 完全二叉树

把一棵具有 $ n $ 个结点的二叉树按层序编号, 若编号为 $ i ( 1 \le i \le n) $ 的结点与同样深度的二叉树中编号为 $ i $ 的结点在二叉树中位置完全相同, 则称此二叉树为完全二叉树

完全二叉树的特点:

1. 叶子结点都出现在最下两层
2. 最下层的叶子结点集中在左部连续位置
3. 倒数第二层若存在叶子结点则全部出现于倒数第二层的最右侧位置
4. 若某结点的度为1, 则其必位于倒数第二层, 且必只有左子树
5. 同样结点数的二叉树, 完全二叉树的深度最小

### 6.6 二叉树的性质

#### 性质1

在二叉树的第 $ i $ 层至多有 $ 2^{i - 1} $ 个结点 $ (i \ge 1) $

#### 性质2

深度为 $ k $ 的二叉树最多有 $ 2^{k} - 1 $ 个结点 $ (k \ge 1) $

#### 性质3

对任意一棵二叉树 T, 如果其终端结点数为 $ n_0 $, 度为2的结点数为 $ n_2 $, 则 $ n_0 = n_2 + 1 $

#### 性质4

具有 $ n $ 个结点的完全二叉树的深度为 $ \left \lfloor \log_2n \right \rfloor + 1$, 也可记为 $ \left \lceil \log_2{n + 1} \right \rceil $

推导:

深度为 $ k $ 的满二叉树的结点数为 $ 2^{k} - 1 $, 反推得 $ n = 2^{k} - 1 $ 个结点的满二叉树深度为 $ k = \log_2(n+1) $

则对于同样深度的完全二叉树, 其结点数大小必定小于或等于同样深度的满二叉树, 但必定比小一深度的满二叉树大, 故有 $ 2^{k-1} - 1 < n \le 2^{k} - 1 $ 移项后取对数有 $ k - 1 < \log_2(n + 1) \le k $ 即由深度 $ k $ 为整数得 $ k = \left \lceil \log_2{n + 1} \right \rceil $

又由于 $ n $ 是整数, 故可改写为 $ 2^{k-1} \le n < 2^{k} $ 取对数得 $ k - 1 \le \log_{2}{n} < k $ 即由深度 $ k $ 为整数得 $ k = \left \lfloor \log_2n \right \rfloor + 1 $

#### 性质5

如果对一棵有 $ n $ 个结点的完全二叉树 (深度为 $ \left \lfloor \log_2n \right \rfloor + 1$) 的结点按层编序 (从第一层到最后一层, 从左到右), 对任一结点 $ j (1 \le j \le n)$有

1. 如果 $ i=1$ 则结点 $ i $ 是二叉树的根, 无双亲; 如果 $ i > 1 $ 则其双亲结点为 $ \left \lfloor {i}/{2} \right \rfloor $
2. 如果 $ 2i > n $ 则结点 $ i $ 无左孩子 (结点 $ i $为叶子结点), 否则其左孩子为 $ 2i $
3. 如果 $ 2i + 1 > n $ 则结点 $ i $ 无右孩子, 否则其右孩子为 $ 2i + 1 $

### 6.7 二叉树的储存结构

#### 6.7.1 二叉树的顺序存储结构

二叉树的顺序存储结构:
> 用一维数组储存二叉树的结点, 将一棵树按完全二叉树编号, 存入对应的下标中, 不存在的结点标记为空
> 由于一般的二叉树可能浪费大量空间, 故一般用于完全二叉树

#### 6.7.2 二叉链表

结点内有一个数据域, 两个指针域, 分别指向左右孩子

```c
typedef struct BiTNode {
    elemType data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;
```

可根据需要增设如指向其双亲的指针等指针域, 增加查找速度

### 6.8 遍历二叉树

#### 6.8.1 二叉树的遍历原理

二叉树的遍历:
> 从根结点出发, 按照某种次序依次访问二叉树中所有结点, 使得每个结点被访问一次, 且仅被访问一次

#### 6.8.2 二叉树的遍历方法

##### 1 前序遍历

> 若二叉树为空, 则空操作返回; 否则先访问根结点, 再前序遍历左子树, 最后前序遍历右子树

##### 2 中序遍历

> 若二叉树为空, 则空操作返回; 否则从根结点开始, 中序遍历左子树, 访问根结点, 最后中序遍历右子树

##### 3 后序遍历

> 若二叉树为空, 则空操作返回; 否则从根结点开始, 后序遍历左子树, 后序遍历右子树, 最后访问根结点

##### 4 层序遍历

> 若二叉树为空, 则空操作返回; 否则从树的第一层即根结点开始, 从上到下逐层遍历, 在同一层内, 从左到右遍历

#### 6.8.3 前序遍历的递归算法

```c
/* PreOrder Traversal */
void PreOrder(BiTree T)
{
    if (T != NULL) {
        printf("%d ", T->data);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}
```

#### 6.8.4 中序遍历的递归算法

```c
/* InOrder Traversal */
void InOrder(BiTree T)
{
    if (T != NULL) {
        InOrder(T->lchild);
        printf("%d ", T->data);
        InOrder(T->rchild);
    }
}
```

#### 6.8.5 后序遍历的递归算法

```c
/* PostOrder Traversal */
void PostOrder(BiTree T)
{
    if (T != NULL) {
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        printf("%d ", T->data);
    }
}
```

#### 6.8.6 推导遍历结果

### 6.9 二叉树的建立

```c
/* Create a binary tree */
void CreateBiTree(BiTree *T)
{
    elemType ch;
    scanf("%c", &ch);
    if (ch == '#') {
        *T = NULL;
    } else {
        *T = (BiTree)malloc(sizeof(BiTNode));
        if (!*T) {
            exit(OVERFLOW);
        }
        (*T)->data = ch;
        CreateBiTree(&(*T)->lchild);
        CreateBiTree(&(*T)->rchild);
    }
}
```

### 6.10 线索二叉树

#### 6.10.1 线索二叉树的原理

为利用二叉链表中的空指针域, 使其指向前驱或后继结点, 从而提高遍历效率

> 线索: 指向前驱或后继的指针
> 线索链表: 加上线索的二叉链表
> 线索二叉树: 线索链表对应的二叉树
> 线索化: 对二叉树以某种次序遍历使其变为线索二叉树的过程

线索二叉树可以达到将一棵二叉树转化为双向链表的目的

为区分指针域指向孩子还是前驱后继, 需要增设标志位 `ltag` 和 `rtag`

对于 `lchild` 指针: 若 `ltag = 0` 则指向左孩子, 若 `ltag = 1` 则指向前驱

对于 `rchild` 指针: 若 `rtag = 0` 则指向右孩子, 若 `rtag = 1` 则指向后继

#### 6.10.2 线索二叉树结构的实现

实现代码如下

```c
typedef enum {link, thread} pointerTag;

typedef struct biThrNode {
    elemType data;
    struct biThrNode *lchild, *rchild;
    pointerTag ltag, rtag;
} biThrNode, *biThrTree;
```

#### 6.10.3 线索二叉树的线索化

线索化的过程即遍历二叉树的过程, 在遍历的过程中, 将空指针域指向前驱或后继

中序线索化的过程如下

```c
biThrTree pre = NULL;
void InThreading(biThrTree p)
{
    if (p) {
        InThreading(p->lchild);
        if (!p->lchild) {
            p->ltag = thread;
            p->lchild = pre;
        }
        if (!pre->rchild) {
            pre->rtag = thread;
            pre->rchild = p;
        }
        pre = p;
        InThreading(p->rchild);
    }
}
```

有了线索二叉树后, 进行相应的遍历即为操作一双向链表的过程

可以选择增加一头结点令其 `lchild` 指向线索二叉树的root结点, `rchild` 指向遍历时访问的最后一个结点,与此同时, 使遍历时的第一个结点的 `lchild` 最后一个结点的 `rchild` 均指向该头结点, 方便从第一个结点进行顺后驱遍历或者从最后一个结点进行顺前驱遍历

遍历的代码如下

```c
status inOrderTraverse_Thr(biThrTree T)
{
    biThrTree p;
    p = T->lchild;
    while (p != T) {
        while (p->ltag == link) {
            p = p->lchild;
        }
        printf("%c ", p->data);
        while (p->rtag == thread && p->rchild != T) {
            p = p->rchild;
            printf("%c ", p->data);
        }
        p = p->rchild;
    }
    return OK;
}
```

本质上为链表的扫描, 故复杂度为 $ O(n) $

### 6.11 树、森林与二叉树的转换

#### 6.11.1 树转换为二叉树

将树转换为二叉树的过程为:

1. 加线: 在所有的兄弟结点之间加一条线
2. 去线: 对树中每个结点, 只保留它与第一个孩子结点之间的连线, 去掉它与其它孩子结点之间的连线
3. 层次调整: 以树的根结点为二叉树的根, 其它结点进行相应的层次调整, 注意结点的第一个孩子是二叉树结点的左孩子, 其兄弟是二叉树结点的右孩子

#### 6.11.2 森林转换为二叉树

将森林转换为二叉树的过程为:

1. 将森林中每棵树转换为二叉树
2. 从第二棵树开始, 依次把后一棵树的根节点作为前一棵树的根节点的右孩子, 直到整个森林转换为一棵二叉树

#### 6.11.3 二叉树转换为树

将二叉树转换为树的过程为:

1. 加线: 若某结点的左孩子存在, 则将此左孩子的右孩子以及此右孩子后的 $ n $ 个右孩子都作为此左孩子的兄弟, 即初始结点的孩子
2. 去线: 删除所有结点与其右孩子之间的连线
3. 层次调整

#### 6.11.4 二叉树转换为森林

将二叉树转换为森林的过程为:

1. 从根节点开始, 若右孩子存在, 则将其与右孩子之间的连线删除, 随后处理被分离的右孩子, 直至右孩子不存在, 从而将所有树分离
2. 将分离后的二叉树转换为树

#### 6.11.5 树与森林的遍历

##### 树的遍历方式

1. 先根遍历: 先访问根结点, 再依次先根遍历每棵子树 (对应二叉树的前序遍历, 与其转换为二叉树后的前序遍历结果相同)
2. 后根遍历: 先依次后根遍历每棵子树, 再访问根结点 (对应二叉树的后序遍历, 与其转换为二叉树后的中序遍历结果相同)

##### 森林的遍历方式

1. 先序遍历: 先对第一棵树进行先根遍历, 随后以同样的方式遍历除去第一棵树组成的森林 (与其转换为二叉树后的前序遍历结果相同)
2. 后序遍历: 先对第一棵树进行后根遍历, 随后以同样的方式遍历除去第一棵树组成的森林 (与其转换为二叉树后的中序遍历结果相同)

### 6.12 哈夫曼树及其应用 (树的应用)

#### 6.12.2 哈夫曼树的定义和原理

> 带权二叉树: 二叉树中的结点 (一般为叶子节点) 带有权值
> 路径长度: 从根结点到第 $ i $ 个叶子结点的路径上的分支结点个数
> 树的路径长度: 树中所有结点的路径长度之和
> 结点的带权路径长度: 从根结点到该结点的路径长度与该结点的权值的乘积
> 树的带权路径长度: 树中所有叶子结点的带权路径长度之和
> 哈夫曼树: 给定 $ n $ 个带权叶子节点, 构造出的带权路径长度 (WPL) 最小的二叉树, 也称最优二叉树

哈夫曼树的构造过程:

1. 将 $ n $ 个结点按照权值从小到大排序
2. 取出权值最小的两个结点 (或者树), 构造一棵新的二叉树, 其根结点 $ N_1 $的权值为这两个结点的权值之和, 左孩子为较小的结点, 右孩子为较大的结点, 随后以 $ N_1 $ 为根结点的树视为一个结点插入到原序列中并保持从小到大的顺序
3. 重复上一步骤, 直至所有结点构造为一棵二叉树

#### 6.12.3 哈夫曼编码

> 前缀编码: 若要设计长短不等的编码, 则必须保证任何一个编码都不是另一个编码的前缀
> 哈夫曼编码: 一种变长编码, 由于哈夫曼树的特性, 可以保证任意字符的编码不是另一个字符的前缀, 从而可以实现无歧义的解码

哈夫曼编码的过程:

1. 将需要编码的字符按照某种权值构造哈夫曼树
2. 向左走为 0, 向右走为 1, 从根结点到叶子结点的路径即为该字符的编码

解码过程:
根据进行哈夫曼编码的哈夫曼树, 从根结点开始, 依次根据编码的 0 或 1 向左或向右走, 直至走到叶子结点, 则得到对应的字符

## 第七章 图

### 7.2 图的定义

> 图 (graph): 由顶点 (vertex) 的有穷非空集合和顶点之间的边的集合组成, 通常表示为 $ G(V, E) $, 其中 $ G $ 表示一个图, $ V $ 表示图 $ G $ 中顶点的集合, $ E $ 表示图 $ G $ 中边的集合

| 数据结构 | 数据元素名称 |  可否为空  |
| :------: | :----------: | :--------: |
|  线性表  |     元素     |     是     |
|    树    |     结点     |     是     |
|    图    |     顶点     | 一般认为否 |

#### 7.2.1 图的基本术语

> 无向边 (edge): 顶点 $ v_i $ 到顶点 $ v_j $ 的边没有方向, 用无序偶对记为 $ (v_i, v_j) $ 或 $ (v_j, v_i) $
> 无向图: 图中任意两个顶点之间的边都是无向边的图
> 有向边 : 顶点 $ v_i $ 到顶点 $ v_j $ 的边有方向, 也称为弧 (arc), 用有序偶对记为 $ <v_i, v_j> $, $ v_i $ 称为弧尾 (tail), $ v_j $ 称为弧头 (head)
> 有向图 (directed graph): 图中任意两个顶点之间的边都是有向边的图
> 简单图: 不存在顶点到其自身的边, 且同一条边不重复出现
> 完全无向图: 任意两个顶点之间都存在边的无向图, 含有 $ n $ 个顶点的完全无向图的边数为 $ \frac{n(n-1)}{2} $
> 完全有向图: 任意两个顶点之间都存在方向相反的弧有向图, 含有 $ n $ 个顶点的完全有向图的弧数为 $ n(n-1) $
> 稀疏图: 边数远小于完全图的图, 反之为稠密图
> 权 (weight): 边或弧上的数值, 代表两个顶点之间的距离或耗费等数值
> 网络 (network): 带权的图
> 子图 (subgraph): 如果有两个图 $ G = (V, E) $ 和 $ G' = (V', E') $, 且 $ V' \subseteq V $, $ E' \subseteq E $, 则称 $ G' $ 是 $ G $ 的子图

#### 7.2.2 图的顶点与边之间的关系

##### 无向图的顶点与边之间的关系

> 无向图的顶点与边之间的关系: 对于无向图 $ G = (V, E) $, 若 $ (v_i, v_j) \in E $, 则称顶点 $ v_i $ 与顶点 $ v_j $ 相邻接, 也称边 $ (v_i, v_j) $ 依附于顶点 $ v_i $ 和 $ v_j $, 或者称顶点 $ v_i $ 与顶点 $ v_j $ 相关联
> 顶点的度 (degree): 与顶点 $ v $ 相关联的边的数目, 记为 $ TD(v) $
> 边数 $e$和顶点的度的关系为 $ e = \frac{1}{2} \sum_{v \in V} TD(v) $

##### 有向图的顶点与边之间的关系

> 有向图的顶点与边之间的关系: 对于有向图 $ G = (V, E) $, 若 $ <v_i, v_j> \in E $, 则称顶点 $ v_i $ 邻接到顶点 $ v_j $, 也称顶点 $ v_i $ 与顶点 $ v_j $ 相关联
> 顶点的入度: 以顶点 $ v $ 为终点的弧的数目,或者说以顶点 $v$ 为头的数目, 记为 $ ID(v) $
> 顶点的出度: 以顶点 $ v $ 为起点的弧的数目,或者说以顶点 $v$ 为尾的数目, 记为 $ OD(v) $
> 顶点的度: 顶点的入度和出度之和, 记为 $ TD(v) = ID(v) + OD(v) $
> 边数 $ e $ 和顶点的度的关系为 $ e = \sum_{v \in V} OD(v) = \sum_{v \in V} ID(v) $

##### 顶点序列

> 顶点序列: 无向图或有向图中, 顶点  $ v $ 到 $ v' $ 的一个顶点序列, 记为 $ (v=v_{i, 0}, v_{i, 1}, \cdots, v_{i, m} = v') $, 其中 $ v_{i, j-1} $ 与 $ v_{i, j} $ 相邻接, 且 $ 1 \le j \le m $, 对于无向图应满足 $ (v_{i, j-1}, v_{i, j}) \in E $, 对于有向图应满足 $ <v_{i, j-1}, v_{i, j}> \in E $
> 路径的长度: 路径上的边或弧的数目
> 回路或环 (cycle): 第一个顶点与最后一个顶点相同的路径
> 简单路径: 序列中顶点不重复的路径
> 简单回路或简单环: 除了第一个顶点和最后一个顶点外, 其余顶点不重复的回路

#### 7.2.3 连通图的相关术语

> 顶点 $ v $ 与 $ v' $ 连通: 顶点 $ v $ 与 $ v' $ 之间存在路径
> 连通图: 无向图 $ G $ 中, 任意两个顶点之间都存在路径的图
> 连通分量: 无向图中极大连通子图, 有如下要求
    > 子图
    > 子图连通
    > 子图有极大顶点数
    > 具有极大顶点数的连通子图包含依附于这些顶点的所有边
> 强连通图: 有向图 $ G $ 中, 任意两个顶点之间都存在路径, 且路径是有向的
> 强连通分量: 有向图中极大强连通子图
> 连通图的生成树: 一个连通图的生成树是一个极小的连通子图, 它含有图中全部的 $ n $ 个顶点, 但只有足以构成一棵树的 $ n-1 $ 条边
> 有向树: 一个有向图有一个顶点的入度为 $ 0 $, 其余顶点的入度为 $ 1 $, 且是一个连通图
> 有向图的生成森林: 由若干有向树组成, 含有图中全部顶点, 但只有足以构成若干棵有向树的弧

简单无向图中边的数量范围: $ 0 \le e \le \frac{n(n-1)}{2} $
简单有向图中边的数量范围: $ 0 \le e \le n(n-1) $
连通图中边的数量范围: $ n-1 \le e \le \frac{n(n-1)}{2} $
强连通图中边的数量范围: $ n-1 \le e \le n(n-1) $

### 7.3 图的抽象数据类型

```ADT
ADT 图 (Graph)
Data
    顶点的有穷非空集合和边的有穷集合
Operation
    create_graph(*G, V, VR)
    destroy_graph(*G)
    locate_vex(G, u)
    get_vex(G, v)
    put_vex(*G, v, value)
    first_adjvex(G, v)
    next_adjvex(G, v, w)
    insert_vex(*G, v)
    delete_vex(*G, v)
    insert_arc(*G, v, w)
    delete_arc(*G, v, w)
    DFS_traverse(G)
    BFS_traverse(G)
end ADT
```

### 7.4 图的存储结构

#### 7.4.1 邻接矩阵

> 邻接矩阵: 用两个数组来表示图中的顶点和边, 一个一维数组存储顶点信息, 一个二维数组 (邻接矩阵) 存储边信息

若图 $ G = (V, E) $ 中有 $n$ 个顶点, 则其邻接矩阵为一个 $n \times n$ 的矩阵, 定义为:

$$
arg[i][j] = \begin{cases}
1, & if\quad{(v_i, v_j) \in E}\quad or \quad{<v_i, v_j> \in E} \\
0, & others \\
\end{cases}
$$

对于无向图, 邻接矩阵为对称矩阵, 对角线上的元素为 $ 0 $

对于无向图, 邻接矩阵为非对称矩阵, 对角线上的元素为 $ 0 $

对于无向图, 结点 $v_i$ 的度为邻接矩阵第 $i$ 行或第 $i$ 列的元素之和

对于有向图, 结点 $v_i$ 的出度为邻接矩阵第 $i$ 行的元素之和, 入度为邻接矩阵第 $i$ 列的元素之和

若图 $G$ 为网, 有 $n$ 个顶点, 则邻接矩阵为一个 $n \times n$ 的矩阵, 定义为:

$$
arg[i][j] = \begin{cases}
w_{ij}, & if\quad{(v_i, v_j) \in E}\quad or \quad{<v_i, v_j> \in E} \\
0, & if \quad {i = j} \\
\infty, & others \\
\end{cases}
$$

其中 $w_{ij}$ 表示边或弧的权值

图的邻接矩阵储存结构

```c
#define MAXVEX 100
#define INFINITY 65535
typedef char vertexType;
typedef int edgeType;

typedef struct {
    vertexType vexs[MAXVEX];
    edgeType arc[MAXVEX][MAXVEX];
    int num_vertexes, num_edges;
} MGraph;
```

创建图的邻接矩阵

```c
void createMGraph(mGraph *G)
{
    int i, j, k, w;
    printf("Enter the number of vertexes and edges: ");
    scanf("%d %d", &G->num_vertexes, &G->num_edges);
    for (i = 0; i < G->num_vertexes; i++) {
        printf("Enter the vertex %d: ", i);
        scanf("%c", &G->vexs[i]);
    }
    for (i = 0; i < G->num_vertexes; i++) {
        for (j = 0; j < G->num_vertexes; j++) {
            G->arc[i][j] = INFINITY;
        }
    }
    for (k = 0; k < G->num_edges; k++) {
        printf("Enter the edge (vi, vj) and its weight: ");
        scanf("%d %d %d", &i, &j, &w);
        G->arc[i][j] = w;
        G->arc[j][i] = G->arc[i][j];
    }
}
```

时间复杂度为 $ O(n+n^2+e) $, 其中对邻接矩阵的初始化耗费了 $ O(n^2) $ 的时间

#### 7.4.2 邻接表

> 邻接表: 用一个一维数组存储图中的顶点信息, 每个结点用一个线性表存储每个顶点的邻接顶点信息
> 顶点表: 储存各顶点的线性表 (一般为顺序表), 由数据域和指向第一个邻接点的指针域组成
> 边表: 对于无向图此线性表称为顶点 $v_i$ 的边表, 对于有向图, 顶点 $v_i$ 的边表称为弧尾的出边表, 边表为一链表, 由邻接点域和指向下一个邻接点的指针域组成,若为网, 则还有一个权值域
> 逆邻接表: 有向图中若每个顶点都建立一个链接为 $ v_i $ 为弧头的表, 则称为弧尾的入边表, 建立的表称为逆邻接表

图的邻接表储存结构

```c
typedef struct edgeNode{
    int adjvex;
    edgeType weight;    // for net
    struct edgeNode *next;
} edgeNode;

typedef struct vertexNode {
    vertexType data;
    edgeNode *firstEdge;
} vertexNode, adjList[MAXVEX];

typedef struct {
    adjList adj_list;
    int num_vertexes, num_edges;
} graphAdjList;
```

创建图的邻接表

```c
void createALGraph(graphAdjList *G)
{
    int i, j, k;
    edgeNode *e;
    printf("Enter the number of vertexes and edges: ");
    scanf("%d %d", &G->num_vertexes, &G->num_edges);
    for (i = 0; i < G->num_vertexes; i++) {
        printf("Enter the vertex %d: ", i);
        scanf("%c", &G->adj_list[i].data);
        G->adj_list[i].firstEdge = NULL;
    }
    for (k = 0; k < G->num_edges; k++) {
        printf("Enter the edge (vi, vj): ");
        scanf("%d %d", &i, &j);
        e = (edgeNode *)malloc(sizeof(edgeNode));
        e->adjvex = j;
        e->next = G->adj_list[i].firstEdge;
        G->adj_list[i].firstEdge = e;

        e = (edgeNode *)malloc(sizeof(edgeNode));
        e->adjvex = i;
        e->next = G->adj_list[j].firstEdge;
        G->adj_list[j].firstEdge = e;
    }
}
```

对于有 $n$ 个顶点和 $e$ 条边的图, 邻接表的时间复杂度为 $ O(n+e) $

#### 7.4.3 十字链表

> 十字链表: 有向图的一种链表存储结构, 由顶点表和边表组成, 顶点表中的结点包含顶点信息和指向第一个入边表和出边表的指针, 边表中的结点包含边的信息和指向弧头和弧尾的指针

#### 7.4.4 邻接多重表

> 邻接多重表: 无向图的一种链表存储结构, 由顶点表和边表组成, 顶点表中的结点包含顶点信息和指向第一个边表的指针, 边表中的结点包含边的信息和指向两个顶点的指针

#### 7.4.5 边集数组 (edgeset array)

> 边集数组: 由边的集合构成的数组, 每个元素为一个边的信息, 通常包括边的起点, 终点和权值

### 7.5 图的遍历

#### 7.5.1 深度优先遍历 (DFS)

> 深度优先遍历 (Depth First Search, DFS): 从图中某个顶点 $v$ 出发, 访问此顶点, 然后从 $v$ 的未被访问的邻接点出发深度优先遍历图, 直至图中所有和 $v$ 有路径相通的顶点都被访问到, 若此时图中尚有顶点未被访问, 则另选图中一个未曾访问的顶点作为起始点, 重复上述过程, 直至图中所有顶点都被访问到为止, 若图为非连通图, 则从某个未曾访问的顶点出发重新进行深度优先遍历, 直至图中所有顶点都被访问到为止

DFS类似于树的先序遍历

对邻接矩阵表示的图进行深度优先遍历

```c
bool visited[MAXVEX];

void DFS_MG(mGraph G, int i)
{
    int j;
    visited[i] = TRUE;
    printf("%c ", G.vexs[i]);
    for (j = 0; j < G.num_vertexes; j++) {
        if (G.arc[i][j] == 1 && !visited[j]) {
            DFS(G, j);
        }
    }
}

void DFSTraverse_MG(mGraph G)
{
    int i;
    for (i = 0; i < G.num_vertexes; i++) {
        visited[i] = FALSE;
    }
    for (i = 0; i < G.num_vertexes; i++) {
        if (!visited[i]) {
            DFS(G, i);
        }
    }
}

```

时间复杂度为 $ O(n^2) $

邻接表表示的图进行深度优先遍历

```c
void DFS(graphAdjList GL, int i)
{
    edgeNode *p;
    visited[i] = true;
    printf("%c ", GL.adj_list[i].data);
    p = GL.adj_list[i].firstEdge;
    while (p) {
        if (!visited[p->adjvex]) {
            DFS(GL, p->adjvex);
        }
        p = p->next;
    }
}

void DFSTraverse(graphAdjList GL)
{
    int i;
    for (i = 0; i < GL.num_vertexes; i++) {
        visited[i] = false;
    }
    for (i = 0; i < GL.num_vertexes; i++) {
        if (!visited[i]) {
            DFS(GL, i);
        }
    }
}
```

时间复杂度为 $ O(n+e) $

#### 7.5.2 广度优先遍历 (BFS)

> 广度优先遍历 (Breadth First Search, BFS): 从图中某个顶点 $v$ 出发, 访问此顶点, 然后依次访问 $v$ 的所有未曾访问的邻接点, 再依次访问这些邻接点的邻接点, 直至图中所有和 $v$ 有路径相通的顶点都被访问到, 若此时图中尚有顶点未被访问, 则另选图中一个未曾访问的顶点作为起始点, 重复上述过程, 直至图中所有顶点都被访问到为止, 若图为非连通图, 则从某个未曾访问的顶点出发重新进行广度优先遍历, 直至图中所有顶点都被访问到为止

BFS类似于树的层次遍历

对邻接矩阵表示的图进行广度优先遍历

```c
void BFSTraverse_MG(mGraph G)
{
    int i, j;
    queue Q;
    for (i = 0; i < G.num_vertexes; i++) {
        visited[i] = FALSE;
    }
    initQueue(&Q);
    for (i = 0; i < G.num_vertexes; i++) {
        if (!visited[i]) {
            visited[i] = TRUE;
            printf("%c ", G.vexs[i]);
            enQueue(&Q, i);
            while (!isEmpty(Q)) {
                deQueue(&Q, &i);
                for (j = 0; j < G.num_vertexes; j++) {
                    if (G.arc[i][j] == 1 && !visited[j]) {
                        visited[j] = TRUE;
                        printf("%c ", G.vexs[j]);
                        enQueue(&Q, j);
                    }
                }
            }
        }
    }
}
```

对邻接表表示的图进行广度优先遍历

```c
void BFSTraverse_GL(graphAdjList GL)
{
    int i;
    edgeNode *p;
    queue Q;
    for (i = 0; i < GL.num_vertexes; i++) {
        visited[i] = FALSE;
    }
    initQueue(&Q);
    for (i = 0; i < GL.num_vertexes; i++) {
        if (!visited[i]) {
            visited[i] = TRUE;
            printf("%c ", GL.adj_list[i].data);
            enQueue(&Q, i);
            while (!isEmpty(Q)) {
                deQueue(&Q, &i);
                p = GL.adj_list[i].firstEdge;
                while (p) {
                    if (!visited[p->adjvex]) {
                        visited[p->adjvex] = TRUE;
                        printf("%c ", GL.adj_list[p->adjvex].data);
                        enQueue(&Q, p->adjvex);
                    }
                    p = p->next;
                }
            }
        }
    }
}
```

### 7.6 最小生成树

> 最小生成树: 一个连通图的生成树, 其中包含图中全部 $n$ 个顶点, 且只有足以构成一棵树的 $n-1$ 条边, 使得这棵树上所有边的权值之和最小

#### 7.6.1 Prim 算法

> Prim 算法: 从一个顶点出发, 每次找到与当前生成树相邻的权值最小的边, 并将其加入生成树, 直至生成树中包含 $n-1$ 条边
> Prim 算法的实现: 假设 $N=(V, E)$ 是一个连通网, $T=(U, TE)$ 是 $N$ 的最小生成树, $U$ 是 $V$ 的子集, $TE$ 是 $E$ 的子集, 初始时 $U = \{u_0\}$, $TE = \emptyset$, 重复以下操作, 直至 $U = V$
    > 在所有的 $u \in U$ 和 $v \in V-U$ 之间的边中找到权值最小的边 $<u, v>$, 将 $v$ 加入 $U$, 将 $<u, v>$ 加入 $TE$

```c
void miniSpanTree_Prim(mGraph G)
/* Get the miniest spanning tree of graph G by Prim algorithm */
{
    int min, i, j, k;
    int adjvex[MAXVEX];  // Save the vertex of the edge
    int lowcost[MAXVEX]; // Save the weight of the edge
    lowcost[0] = 0;      // The first vertex is in the tree
    adjvex[0] = 0;       // The first vertex is in the tree
    for (i = 1; i < G.num_vertexes; i++) {
        lowcost[i] = G.arc[0][i]; // Save the weight of the edge
        adjvex[i] = 0;            // Save the vertex of the edge
    }
    for (i = 1; i < G.num_vertexes; i++) {
        min = INFINITY; // Initialize the min value
        j = 1;
        k = 0;
        while (j < G.num_vertexes) {
            if (lowcost[j] != 0 && lowcost[j] < min) {
                min = lowcost[j];
                k = j;
            }
            j++;
        }
        printf("(%d, %d)\n", adjvex[k], k); // Print the edge
        lowcost[k] = 0;                     // The vertex k is in the tree
        for (j = 1; j < G.num_vertexes; j++) {
            if (lowcost[j] != 0 && G.arc[k][j] < lowcost[j]) {
                lowcost[j] = G.arc[k][j];
                adjvex[j] = k;
            }
        }
    }
}
```

此实现的时间复杂度为 $ O(n^2) $

#### 7.6.2 Kruskal 算法

> Kruskal 算法: 将图中的所有边按照权值从小到大排序, 依次加入生成树, 若加入的边与生成树形成回路, 则舍弃该边, 直至生成树中包含 $n-1$ 条边
> 并查集 (DSU, Disjoint Set Union): 一种数据结构, 用于维护集合的合并和查找操作, 通常包括两个操作
    > 查找 (find): 查找元素所在的集合
    > 合并 (union): 合并两个集合
> 利用并查集判断是否形成回路: 每次加入一条边, 判断该边的两个顶点是否在同一个集合中, 若在同一个集合中, 则形成回路, 否则将两个集合合并
> Kruskal 算法实现: 假设 $N=(V, E)$ 是一个连通网, $T=(U, TE)$ 是 $N$ 的最小生成树, $U$ 是 $V$ 的子集, $TE$ 是 $E$ 的子集, 初始时 $U = \{u_0\}$, $TE = \emptyset$, 重复以下操作, 直至 $TE$ 中有 $n-1$ 条边
    > 从 $E$ 中选择权值最小的边 $<u, v>$, 若 $u \in U$ 且 $v \in U$, 则舍弃该边, 否则将 $<u, v>$ 加入 $TE$, 并将 $u$ 和 $v$ 加入 $U$

```c
typedef struct {
    int begin;
    int end;
    int weight;
} edge;

void miniSpanTree_Kruskal(mGraph G)
{
    int i, n, m;
    edge edges[MAXEDGE];
    int parent[MAXVEX];     // DSU array
    n = G.num_vertexes;
    m = G.num_edges;

    /* Tranalate the matrix to the edgeset */
    for (i = 0; i < m; i++) {
        edges[i].begin = edges[i].begin;
        edges[i].end = edges[i].end;
        edges[i].weight = edges[i].weight;
    }
    sort(edges, m); // Sort the edges by weight

    for (i = 0; i < n; i++) {   // Initialize the parent array
        parent[i] = 0;
    }
    for (i = 0; i < m; i++) {
        n = find(parent, edges[i].begin);   // Find the parent of the begin vertex in the DSU
        m = find(parent, edges[i].end);     // Find the parent of the end vertex in the DSU
        if (n != m) {
            parent[n] = m;      // Merge the two sets
            printf("(%d, %d) %d\n", edges[i].begin, edges[i].end, edges[i].weight);
        }
    }
}

int find(int *parent, int f)
{
    while (parent[f] > 0) {
        f = parent[f];
    }
    return f;
}
```

此实现的时间复杂度为 $ O(e \log e) $

Prim 算法适用于稠密图, Kruskal 算法适用于稀疏图

### 7.7 最短路径

> 最短路径: 指的是两个顶点之间的路径的权值之和最小, 称路径上第一个顶点为源点, 最后一个顶点为终点, 非网图可视为权值为 $1$ 的网图
> 最短路径长度: 从源点到终点的最短路径的权值之和

#### 7.7.1 Dijkstra 算法

> Dijkstra 算法: 从源点开始, 每次找到与源点距离最短的顶点, 并将其加入最短路径, 然后更新其他顶点到源点的距离, 直至所有顶点都加入最短路径

```c
void shortestPath_Dijkstra(mGraph G, int v0, int *path, int *dist)
{
    int i, j, k, min;
    int flag[MAXVEX];
    for (i = 0; i < G.num_vertexes; i++) {
        flag[i] = 0;
        dist[i] = G.arc[v0][i];
        path[i] = 0;
    }
    flag[v0] = 1;
    dist[v0] = 0;
    path[v0] = -1;
    for (i = 1; i < G.num_vertexes; i++) {
        min = INFINITY;
        for (j = 0; j < G.num_vertexes; j++) {
            if (!flag[j] && dist[j] < min) {
                min = dist[j];
                k = j;
            }
        }
        flag[k] = 1;
        for (j = 0; j < G.num_vertexes; j++) {
            if (!flag[j] && min + G.arc[k][j] < dist[j]) {
                dist[j] = min + G.arc[k][j];
                path[j] = k;
            }
        }
    }
}
```

时间复杂度为 $ O(n^2) $

#### 7.7.2 Floyd 算法

> Floyd 算法: 用于求解图中任意两个顶点之间的最短路径, 通过动态规划的思想, 逐步求解所有顶点之间的最短路径

```c
void shortestPath_Floyd(mGraph G, int **path, int **dist)
{
    int i, j, k;
    for (i = 0; i < G.num_vertexes; i++) {
        for (j = 0; j < G.num_vertexes; j++) {
            dist[i][j] = G.arc[i][j];
            path[i][j] = -1;
        }
    }
    for (k = 0; k < G.num_vertexes; k++) {
        for (i = 0; i < G.num_vertexes; i++) {
            for (j = 0; j < G.num_vertexes; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = k;
                }
            }
        }
    }
}
```

时间复杂度为 $ O(n^3) $

### 7.8 拓扑排序

#### 7.8.1 拓扑排序

> AOV 网 (Activity On Vertex Network): 用有向图表示的工程, 顶点表示活动, 弧表示活动之间的优先关系, AOV 网中不允许有回路
> 拓扑序列: 对有向图 $G$ 的所有顶点进行线性序列, 使得对图中的每一条有向边 $<v_i, v_j>$, 在序列中顶点 $v_i$ 在顶点 $v_j$ 之前
> 拓扑排序: 对有向图进行拓扑排序, 即求出满足拓扑序列的过程
    > 全部顶点被输出: 网为一AOV网
    > 仅部分顶点被输出: 网中有回路

#### 7.8.2 拓扑排序算法

> 算法: 从 AOV 网中选择一个没有前驱的顶点输出, 从网中删除该顶点及所有以该顶点为尾的弧, 重复上述过程, 直至全部顶点都被输出或者网中不存在无前驱的顶点为止

```c
/* 使用邻接表储存图, 为方便计算, 顶点数组中各个顶点储存其入度 */
typedef struct edgeNode {
    int adjvex;
    struct edgeNode *next;
    int weight;
} edgeNode;

typedef struct vertexNode {
    int in;
    vertexType data;
    edgeNode *firstEdge;
} vertexNode, adjList[MAXVEX];

typedef struct {
    adjList adj_list;
    int num_vertexes, num_edges;
} graphAdjList;

status topologicalSort(graphAdjList GL)
{
    int i, j, k, gettop;
    int top = 0;
    int count = 0;
    int *stack;
    edgeNode *e;
    stack = (int *)malloc(GL.num_vertexes * sizeof(int));
    for (i = 0; i < GL.num_vertexes; i++) {
        if (GL.adj_list[i].in == 0) {
            stack[++top] = i;
        }
    }
    while (top != 0) {
        gettop = stack[top--];
        printf("%d -> ", GL.adj_list[gettop].data);
        count++;
        for (e = GL.adj_list[gettop].firstEdge; e; e = e->next) {
            k = e->adjvex;
            if (!(--GL.adj_list[k].in)) {
                stack[++top] = k;
            }
        }
    }
    if (count < GL.num_vertexes)
        return ERROR;
    else
        return OK;
}
```

时间复杂度为 $ O(n+e) $

### 7.9 关键路径

> AOE 网: 用带权有向图表示的工程, 顶点表示事件, 弧表示活动, 弧上的权值表示活动持续的时间, 没有入边的顶点称为源点或始点, 没有出边的顶点称为汇点或终点
> 路径长度: 从源点到终点的最长路径的权值之和
> 关键路径: 使得整个工程完成时间最短的路径
> 关键活动: 在关键路径上的活动

缩短关键路径上的活动时间, 可以缩短整个工程的完成时间

#### 7.9.1 关键路径算法的原理

> 关键路径算法: 从源点开始, 逐个顶点计算最早开始时间和最晚开始时间, 随后计算各个活动的最早开始时间和最晚开始时间, 最后计算关键路径

计算过程中需要的参数:
    > 事件的最早开始时间 $ve$ (vertex earliest): 顶点 $v_k$ 的最早开始时间
    > 事件的最晚开始时间 $vl$ (vertex latest): 顶点 $v_k$ 的最晚开始时间
    > 活动的最早开始时间 $ee$ (edge earliest): 弧 $<v_i, v_j>$ 的最早开始时间
    > 活动的最晚开始时间 $el$ (edge latest): 弧 $<v_i, v_j>$ 的最晚开始时间

#### 7.9.2 关键路径算法

使用邻接表储存图, 为方便计算, 顶点数组中各个顶点储存其入度, 且边表中各个边储存其权值
首先进行拓扑排序, 然后计算各个顶点的最早开始时间, 最晚开始时间, 随后计算各个活动的最早开始时间, 最晚开始时间, 最后计算关键路径, 关键路径为最早开始时间等于最晚开始时间的活动

求结点的最早开始:

按照拓扑排序的顺序计算, 从起点开始, 逐个顶点计算最早开始时间, 最早开始时间的公式为:

$$
ve[j] = \begin{cases}
0, & When \space k = 0 \\
\max\{ve[i] + len(<v_i, v_k>)\} & When \space k \neq 0 \space and \space <v_i, v_k> \in P[k] \\
\end{cases}
$$

$P[k]$ 表示顶点 $v_k$ 的所有前驱顶点

求结点的最晚开始时间:

按照拓扑排序的逆序计算, 从终点开始, 逐个顶点计算最晚开始时间, 最晚开始时间的公式为:

$$
vl[i] = \begin{cases}
ve[k], & When \space k = n-1 \\
\min\{vl[j] - len(<v_i, v_j>)\} & When \space k < n-1 \space and \space <v_k, v_j> \in S[k] \\
\end{cases}
$$

$S[k]$ 表示顶点 $v_k$ 的所有后继顶点

求活动的最早开始时间:

$$
ee = ve[i]
$$

求活动的最晚开始时间:

$$
el = vl[j] - len(<v_i, v_j>)
$$

求关键路径:

关键路径为最早开始时间等于最晚开始时间的活动

```c
typedef struct edgeNode {
    int adjvex;
    struct edgeNode *next;
    int weight;
} edgeNode;

typedef struct vertexNode {
    int in;
    elemType data;
    edgeNode *firstEdge;
} vertexNode, adjList[MAXSIZE];

typedef struct {
    adjList adj_list;
    int num_vertexes, num_edges;
} graphAdjList;

int *ve, *vl;   // Save the earliest time and latest time
int *stack2;    // Save the topological sort
int top2;       // The top of the stack

status topologicalSort(graphAdjList GL)
/* Topological sort and get the ve */
{
    int i, j, k, gettop;
    int top = 0;
    int count = 0;
    int *stack;
    edgeNode *e;
    stack = (int *)malloc(GL.num_vertexes * sizeof(int));
    for (i = 0; i < GL.num_vertexes; i++) {
        if (GL.adj_list[i].in == 0) {
            stack[++top] = i;
        }
    }
    top2 = 0;
    ve = (int *)malloc(GL.num_vertexes * sizeof(int));
    for (i = 0; i < GL.num_vertexes; i++) {
        ve[i] = 0;
    }
    stack2 = (int *)malloc(GL.num_vertexes * sizeof(int));
    while (top != 0) {  // get topological sort
        gettop = stack[top--];
        count++;
        stack2[++top2] = gettop;
        for (e = GL.adj_list[gettop].firstEdge; e; e = e->next) {   // Get ve
            k = e->adjvex;
            if (!(--GL.adj_list[k].in)) {
                stack[++top] = k;
            }
            if (ve[gettop] + e->weight > ve[k]) {
                ve[k] = ve[gettop] + e->weight;
            }
        }
    }
    if (count < GL.num_vertexes) {
        return ERROR;
    } else {
        return OK;
    }
}

void criticalPath(graphAdjList GL)
{
    int i, j, k, gettop, gettop2;
    int ee, el;
    edgeNode *e;
    topologicalSort(GL);    // Get the topological sort and ve
    vl = (int *)malloc(GL.num_vertexes * sizeof(int));
    for (i = 0; i < GL.num_vertexes; i++) {
        vl[i] = ve[GL.num_vertexes - 1];
    }
    while (top2 != 0) {     // Get vl
        gettop = stack2[top2--];
        for (e = GL.adj_list[gettop].firstEdge; e; e = e->next) {
            k = e->adjvex;
            if (vl[k] - e->weight < vl[gettop]) {
                vl[gettop] = vl[k] - e->weight;
            }
        }
    }
    for (j = 0; j < GL.num_vertexes; j++) { // Get ee, el and critical path
        for (e = GL.adj_list[j].firstEdge; e; e = e->next) {
            k = e->adjvex;
            ee = ve[j];
            el = vl[k] - e->weight;
            if (ee == el) {
                printf("<%d, %d> length: %d\n", GL.adj_list[j].data, GL.adj_list[k].data, e->weight);
            }
        }
    }
}
```

时间复杂度为 $ O(n+e) $, 分为三个部分

1. 拓扑排序并且求 $ve$, 复杂度为 $ O(n+e) $
2. 求 $vl$, 复杂度为 $ O(n+e) $
3. 求 $ee$ 和 $el$, 复杂度为 $ O(n+e) $

## 第八章 查找

### 8.2 查找概论

> 查找: 在数据集合中寻找某个特定的数据元素
> 查找表: 由同一类型的数据元素构成的集合
> 关键字: 查找表中的某个数据元素中的某个数据项的值, 又称为键值
> 关键码: 关键字对应的数据项
> 主关键字: 查找表中唯一标识一个数据元素的关键字
> 次关键字: 可以标识多个数据元素的关键字

查找的分类:
> 静态查找: 查找表中的数据集合是固定的, 查找过程不会改变查找表
> 动态查找: 查找表中的数据集合是动态变化的, 查找过程可能会改变查找表

### 8.3 顺序查找

#### 8.3.1 顺序查找

> 顺序查找: 又叫线性查找, 从查找表的第一个数据元素开始, 逐个与给定的关键字进行比较, 直到找到关键字为止, 或者查找表中的所有数据元素都比较完毕

```c
int sequal_search(int *arr, int n, int key) {
    for (int i = 1; i <= n; i++) {
        if (arr[i] == key) {
            return i;
        }
    }
    return 0;
}
```

时间复杂度为 $ O(n) $

#### 8.3.2 顺序表查找优化

> 顺序查找优化: 通过在查找表中设置一个监视哨, 使得查找过程中不需要判断查找表是否查找完

```c
int sequal_search_opt(int *arr, int n, int key) {
    int i;
    arr[0] = key;
    i = n;
    while (arr[i] != key) {
        i--;
    }
    return i;
}
```

最坏情况下查找次数为 $ n $, 平均查找次数为 $ \frac{(n+1)}{2} $

时间复杂度为 $ O(n) $

### 8.4 有序表查找

#### 8.4.1 折半查找

> 折半查找: 又叫二分查找, 适用于有序顺序表, 通过将查找表分成两部分, 逐步缩小查找范围, 直到找到关键字为止

折半查找过程:

1. 确定查找范围 $[low, high]$
2. 计算中间位置 $mid = (low + high) / 2$
3. 比较中间位置的关键字与给定关键字的大小
    - 若相等, 查找成功
    - 若大于, 则在左半部分继续查找
    - 若小于, 则在右半部分继续查找

```c
int binary_search(int *arr, int n, int key) {
    int low, high, mid;
    low = 1;
    high = n;
    while (low <= high) {
        mid = (low + high) / 2;
        if (arr[mid] == key) {
            return mid;
        } else if (arr[mid] > key) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return 0;
}
```

最坏情况下查找次数为 $ \lceil \log_2 n \rceil $

时间复杂度为 $ O(\log n) $

#### 8.4.2 插值查找

> 插值查找: 针对折半查找的改进, 适用于有序顺序表, 通过对比给定关键字与查找表中最大关键字和最小关键字的比例, 逐步缩小查找范围, 直到找到关键字为止

插值查找公式: $ mid = low + \frac{(key - arr[low])}{arr[high] - arr[low]} \times (high - low) $

```c
int interpolation_search(int *arr, int n, int key) {
    int low, high, mid;
    low = 1;
    high = n;
    while (low <= high) {
        mid = low + (key - arr[low]) / (arr[high] - arr[low]) * (high - low);
        if (arr[mid] == key) {
            return mid;
        } else if (arr[mid] > key) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return 0;
}
```

时间复杂度为 $ O(\log n) $, 适用于关键字分布均匀的有序表

#### 8.4.3 斐波那契查找

```c
int fibonacci_search(int *arr, int n, int key) {
    int low, high, mid, k;
    low = 1;
    high = n;
    k = 0;
    while (n > F[k] - 1) {
        k++;
    }
    for (int i = n; i < F[k] - 1; i++) {
        arr[i] = arr[n];
    }
    while (low <= high) {
        mid = low + F[k - 1] - 1;
        if (arr[mid] == key) {
            if (mid <= n) {
                return mid;
            } else {
                return n;
            }
        } else if (arr[mid] > key) {
            high = mid - 1;
            k = k - 1;
        } else {
            low = mid + 1;
            k = k - 2;
        }
    }
    return 0;
}
```

时间复杂度为 $ O(\log n) $

### 8.5 线性索引查找

> 索引: 把一个关键字与记录的地址联系起来的数据结构
> 索引项: 索引表中的一个元素, 由关键字和指向对应数据块的指针构成
> 线性索引: 又称索引表, 由若干索引项构成的线性表

#### 8.5.1 稠密索引

> 稠密索引: 索引表中的每个数据块都有一个索引项, 索引项一般按照关键字的大小顺序排列, 适用于数据块较小的情况

#### 8.5.2 分块索引

> 分块索引: 将数据分成若干块, 每一块对应一个索引项, 索引项中包含该块的最大关键字和指向该块的指针, 适用于数据块较大的情况

索引块的特点:

1. 块内无序
2. 块间有序, 要求下一块中的所有数据项都大于上一块中的最大数据项

分块索引查找过程:

1. 在索引表中查找关键字所在的块
2. 根据块首指针找到相应的块, 在块中查找关键字

平均查找长度: 设 $n$ 为数据元素个数, $m$ 为块的个数, 每个块中有 $t$ 个数据元素, 显然有有 $n = mt$

设 $L_b$ 为查找索引表的平均查找长度, 其平均长度为 $L_b = \frac{m+1}{2}$

设 $L_w$ 为查找一个块的平均查找长度, 其平均长度为 $L_w = \frac{t+1}{2}$

分块索引的平均查找长度为 $ ASL_w = L_b + L_w = \frac{m+1}{2} + \frac{t+1}{2} = \frac{1}{2}(m+t) + 1 $

当分块为最佳情况时, 即分的块数 $m$ 与每块的数据元素个数 $t$ 使得 $ ASL_w $ 最小, 此时有 $ n = mt = t^2 = m^2 $, 代入 $ ASL_w $ 中, 得到 $ ASL_w = \sqrt{n} + 1 $

#### 8.5.3 倒排索引

> 倒排索引: 索引项中包含次关键码和记录号表, 记录号表中的数据项是具有相同次关键码的记录的记录号 (可以是指向记录的指针或者记录的主关键字)

### 8.6 二叉排序树

> 二叉排序树: 又称二叉查找树, 一棵空树或者具有以下性质的二叉树
    1. 若左子树不空, 则左子树上所有结点的关键字均小于根结点的关键字
    2. 若右子树不空, 则右子树上所有结点的关键字均大于根结点的关键字
    3. 左右子树也分别为二叉排序树

#### 8.6.1 二叉排序树的查找

```c
typedef struct BSTNode {
    elemType data;
    struct BSTNode *lchild, *rchild;
} BSTNode, *BSTree;

int search_BST(BSTree T, elemType key, BSTree f, BSTree *p)
{
    if (!T) {
        *p = f;
        return FALSE;
    } else if (key == T->data) {
        *p = T;
        return TRUE;
    } else if (key < T->data) {
        return search_BST(T->lchild, key, T, p);
    } else {
        return search_BST(T->rchild, key, T, p);
    }
}
```

#### 8.6.2 二叉排序树的插入

```c
int insert_BST(BSTree *T, elemType key)
{
    BSTree p, s;
    if (!search_BST(*T, key, NULL, &p)) {
        s = (BSTree)malloc(sizeof(BSTNode));
        s->data = key;
        s->lchild = s->rchild = NULL;
        if (!p) {
            *T = s;
        } else if (key < p->data) {
            p->lchild = s;
        } else {
            p->rchild = s;
        }
        return TRUE;
    } else {
        return FALSE;
    }
}
```

#### 8.6.3 二叉排序树的删除

> 二叉排序树的删除: 删除结点 $p$ 时, 有三种情况
    1. $p$ 为叶子结点, 直接删除
    2. $p$ 只有左子树或者右子树, 删除 $p$ 后, 将其左子树或者右子树直接连接到其双亲结点上
    3. $p$ 既有左子树又有右子树, 将其右子树中的最小值或者左子树中的最大值替换 $p$, 然后删除替换结点

```c
int delete_BST(BSTree *T, elemType key)
{
    if (!*T) {
        return FALSE;
    } else {
        if (key == (*T)->data) {
            return delete(T);
        } else if (key < (*T)->data) {
            return delete_BST(&(*T)->lchild, key);
        } else {
            return delete_BST(&(*T)->rchild, key);
        }
    }
}

int delete(BSTree *p)
{
    BSTree q, s;
    if ((*p)->lchild == NULL) {
        q = *p;
        *p = (*p)->lchild;
        free(q);
    } else if ((*p)->rchild == NULL) {
        q = *p;
        *p = (*p)->rchild;
        free(q);
    } else { // have both lchild and rchild
        q = *p;
        s = (*p)->lchild;
        while (s->rchild) { // find the max node in the left subtree
            q = s;
            s = s->rchild;
        }
        (*p)->data = s->data;
        if (q != *p) {
            q->rchild = s->lchild;
        } else {
            q->lchild = s->lchild;
        }
        free(s);
    }
    return TRUE;
}
```

#### 8.6.4 二叉排序树总结

二叉排序树的查找, 插入, 删除的时间复杂度为 $ O(h) $, 其中 $ h $ 为二叉排序树的高度

二叉排序树的理想状态是平衡二叉树, 其深度与完全二叉树相同, 为 $ \log_2 n $

最坏情况下, 二叉排序树的高度为 $ n $, 此时二叉排序树退化为单链表

### 8.7 平衡二叉树 (AVL 树)

> 平衡二叉树: 又称 AVL 树, 是一棵空树或者具有以下性质的二叉排序树
    1. 左右子树的高度差的绝对值不超过 $1$
    2. 左右子树也分别为平衡二叉树
> 平衡因子 (BF): 二叉树中左子树的高度减去右子树的高度, 即 $BF = h_l - h_r$, 平衡二叉树中所有结点的平衡因子只能为 $-1, 0, 1$
> 最小不平衡子树: 距离插入结点最近的平衡因子绝对值大于 $1$ 的结点为根的子树

#### 8.7.1 平衡二叉树的实现原理

在构建二叉排序树的过程中, 每插入一个结点, 都要检查从插入结点到根结点的路径上的所有结点的平衡因子, 若平衡因子的绝对值大于 $1$, 则需要进行旋转操作进行调整, 使得整棵树重新平衡

旋转操作分为四种:
    1. 根节点BF = -2, 左孩子BF = -1, 左旋转: 以不平衡结点为支点, 使得其右子树变为新的根结点, 不平衡结点变为新根结点的左子树
    2. 根节点BF = 2, 右孩子BF = 1, 右旋转: 以不平衡结点为支点, 使得其左子树变为新的根结点, 不平衡结点变为新根结点的右子树
    3. 根节点BF = -2, 左孩子BF = 1, 先左后右旋转: 先以左孩子为支点左旋转, 再以不平衡结点为支点右旋转
    4. 根节点BF = 2, 右孩子BF = -1, 先右后左旋转: 先以右孩子为支点右旋转, 再以不平衡结点为支点左旋转

#### 8.7.2 平衡二叉树的实现

```c
typedef struct AVLNode {
    elemType data;
    int bf;
    struct AVLNode *lchild, *rchild;
} AVLNode, *AVLTree;

void L_Rotate(AVLTree *p)
{
    AVLTree rc;
    rc = (*p)->rchild;
    (*p)->rchild = rc->lchild;
    rc->lchild = *p;
    *p = rc;
}

void R_Rotate(AVLTree *p)
{
    AVLTree lc;
    lc = (*p)->lchild;
    (*p)->lchild = lc->rchild;
    lc->rchild = *p;
    *p = lc;
}

void LeftBalance(AVLTree *T)
{
    AVLTree lc, rd;
    lc = (*T)->lchild;
    switch (lc->bf) {
    case 1:
        (*T)->bf = lc->bf = 0;
        R_Rotate(T);
        break;
    case -1:
        rd = lc->rchild;
        switch (rd->bf) {
        case 1:
            (*T)->bf = -1;
            lc->bf = 0;
            break;
        case 0:
            (*T)->bf = lc->bf = 0;
            break;
        case -1:
            (*T)->bf = 0;
            lc->bf = 1;
            break;
        }
        rd->bf = 0;
        L_Rotate(&(*T)->lchild);
        R_Rotate(T);
        break;
    }
}

void RightBalance(AVLTree *T)
{
    AVLTree rc, ld;
    rc = (*T)->rchild;
    switch (rc->bf) {
    case -1:
        (*T)->bf = rc->bf = 0;
        L_Rotate(T);
        break;
    case 1:
        ld = rc->lchild;
        switch (ld->bf) {
        case 1:
            (*T)->bf = 0;
            rc->bf = -1;
            break;
        case 0:
            (*T)->bf = rc->bf = 0;
            break;
        case -1:
            (*T)->bf = 1;
            rc->bf = 0;
            break;
        }
        ld->bf = 0;
        R_Rotate(&(*T)->rchild);
        L_Rotate(T);
        break;
    }
}

int insertAVL(AVLTree *T, elemType e, int *taller)
{
    if (!*T) {
        *T = (AVLTree)malloc(sizeof(AVLNode));
        (*T)->data = e;
        (*T)->lchild = (*T)->rchild = NULL;
        (*T)->bf = 0;
        *taller = TRUE;
    } else {
        if (e == (*T)->data) {
            *taller = FALSE;
            return FALSE;
        }
        if (e < (*T)->data) {
            if (!InsertAVL(&(*T)->lchild, e, taller)) {
                return FALSE;
            }
            if (*taller) {
                switch ((*T)->bf) {
                case 1:
                    LeftBalance(T);
                    *taller = FALSE;
                    break;
                case 0:
                    (*T)->bf = 1;
                    *taller = TRUE;
                    break;
                case -1:
                    (*T)->bf = 0;
                    *taller = FALSE;
                    break;
                }
            }
        } else {
            if (!InsertAVL(&(*T)->rchild, e, taller)) {
                return FALSE;
            }
            if (*taller) {
                switch ((*T)->bf) {
                case 1:
                    (*T)->bf = 0;
                    *taller = FALSE;
                    break;
                case 0:
                    (*T)->bf = -1;
                    *taller = TRUE;
                    break;
                case -1:
                    RightBalance(T);
                    *taller = FALSE;
                    break;
                }
            }
        }
    }
    return TRUE;
}
```

平衡二叉树的查找, 插入, 删除的时间复杂度为 $ O(\log n) $

### 8.8 多路查找树 (B 树)

> 多路查找树: 是一种平衡的多路查找树, 其中每个结点可以有多个孩子, 每一个结点处可以储存多个元素
> B 树特点: 适用于外存储的查找, 通过增加结点的度, 减少树的高度, 从而减少查找次数

#### 8.8.1 2-3 树

> 2-3 树: 是一种特殊的 B 树, 每个结点可以有两个孩子 (2 结点) 或者三个孩子 (3 结点), 所有的叶子结点都在同一层, 适用于内存查找
> 2 结点: 包含一个元素和两个孩子(或者没有孩子), 其中左孩子的元素小于结点元素, 右孩子的元素大于结点元素
> 3 结点: 包含两个元素和三个孩子(或者没有孩子), 其中左孩子的元素小于较小结点元素, 中间孩子的元素在两个元素之间, 右孩子的元素大于较大结点元素

##### 1. 2-3 树的插入

可分为三种情况:
    1. 对于空树, 直接插入一个 2 结点
    2. 插入到 2 结点: 直接插入, 使其变为 3 结点
    3. 插入到 3 结点: 选择一个中间值, 将其插入到父结点, 剩下的两个值分别作为两个 2 结点插入, 如果父结点为 3 结点, 则递归向上插入

##### 2. 2-3 树的删除

可分为三种情况:
    1. 删除 3 结点叶子结点: 直接删除, 使其变为 2 结点
    2. 删除 2 结点叶子结点: 分为四种情况:
       1. 此节点双亲为 2 结点, 兄弟为 3 结点: 将双亲节点的一个元素下移, 兄弟节点的一个元素上移
       2. 此节点双亲为 2 结点, 兄弟为 2 结点: 将双亲节点的一个元素下移, 与兄弟节点合并, 使其变为 3 结点, 递归向上删除
       3. 此节点双亲为 3 结点: 将双亲结点拆分为两个 2 结点, 并与兄弟节点合并
       4. 树为满树: 减少树的层数
    3. 删除非叶子节点: 选择前驱或者后继结点替换, 随后删除替换的叶子结点

#### 8.8.2 2-3-4 树

> 2-3-4 树: 是一种特殊的 B 树, 每个结点可以有两个孩子 (2 结点), 三个孩子 (3 结点) 或者四个孩子 (4 结点), 所有的叶子结点都在同一层, 适用于内存查找
> 4 结点: 包含三个元素和四个孩子(或者没有孩子)

#### 8.8.3 B 树

> B 树: 是一种多路查找树, 其中每个结点可以有多个孩子, 每一个结点处可以储存多个元素, 适用于外存储查找
> B 树的阶: 结点的最大孩子数, 通常用 $m$ 表示

一个 $m$ 阶的 B 树满足以下条件:

1. 若根结点不是叶子结点, 则至少有两个孩子
2. 每个非根的分支结点都有 $k-1$ 个关键字和 $k$ 个孩子, 其中 $\left \lceil m/2 \right \rceil \leq k \leq m$
3. 每个叶子结点都有 $l-1$ 个关键字, 其中 $\left \lceil m/2 \right \rceil \leq l \leq m$
4. 所有的叶子结点都在同一层
5. 分支结点的关键字按递增顺序排列, 孩子结点的关键字分别小于其父结点的关键字且大于其前一个关键字

对于一个有 $n$ 个关键字的 $m$ 阶 B 树, 其最坏情况下的查找次数为 $ \log_{\left \lceil \frac{m}{2} \right \rceil} (\frac{n+1}{2}) + 1 $

#### 8.8.4 B+ 树

B 树为外储存查找而设计, 遍历 B 树时, 需要遍历所有的分支结点, 为了减少遍历次数, 减少磁盘 I/O 次数, 出现了 B+ 树

> B+ 树: 是一种多路查找树, 其中每个结点可以有多个孩子, 每一个结点处可以储存多个元素, 所有的叶子结点都在同一层, 适用于外存储查找

B+ 树和 B 树的区别:

1. 有 $n$ 棵子树的结点中含有 $n$ 个关键字, 即非叶子结点的关键字个数等于其子树个数
2. B+ 树的分支结点不存储数据, 只存储关键字, 叶子结点存储数据
3. B+ 树的叶子结点包含了全部关键字的信息, 叶子结点之间通过指针相连, 方便范围查找

### 8.9 散列表 (哈希表)

#### 8.9.1 散列表查找定义

> 散列: 在记录的存储位置和它的关键字之间建立一个确定的对应关系, 使得每个关键字对应一个存储位置
> 散列函数: 将关键字映射到散列表中的位置的函数, 记为 $H(key)$ 或者 $f$
> 散列表 (哈希表): 通过散列函数将关键字映射到存储位置

#### 8.9.2 散列函数查找步骤

散列过程:

1. 根据关键字计算散列地址, 并将关键字存储在散列表中
2. 查找时, 根据关键字通过同样的散列函数计算散列地址

> 冲突: 两个关键字 $key_1 \neq key_2$, 但是 $H(key_1) = H(key_2)$, 其中 $key_1$ 和 $key_2$ 称为散列函数的同义词

冲突只能减少, 不可避免

### 8.10 散列函数构造方法

散列函数的要求: 简单, 快速, 均匀, 储存利用率高, 散列地址分布均匀 (减少冲突)

选取散列函数的方法应考虑:

1. 计算散列地址的时间复杂度
2. 关键字的长度
3. 散列表的大小
4. 关键字的分布情况
5. 记录查找的频率

#### 8.10.1 直接定址法

> 直接定址法: $H(key) = a \times key + b$, 其中 $a, b$ 为常数

直接定址法的特点: 简单, 适用于关键字分布均匀的情况

#### 8.10.2 数字分析法

> 数字分析法: 通过分析关键字的分布规律, 选择关键字中分布不均匀的部分作为散列地址

#### 8.10.3 平方取中法

> 平方取中法: 将关键字平方, 取中间的几位作为散列地址

#### 8.10.4 折叠法

> 折叠法: 将关键字分割成几部分, 然后将这几部分相加, 取低位作为散列地址

#### 8.10.5 除留余数法

> 除留余数法: $H(key) = key \mod p \quad (p \le m)$, 其中 $p$ 一般为不大于散列表长度的最大质数或者不包含小于 $20$ 的质因子的合数

#### 8.10.6 随机数法

> 随机数法: 通过随机函数生成散列地址

### 8.11 处理冲突的方法

#### 8.11.1 开放定址法

> 开放定址法: 当发生冲突时, 通过一定的规则寻找下一个空的散列地址

##### 1. 线性探测法

> 线性探测法: 出现冲突时, 逐个查找下一个空的散列地址, 公式为:

$$
H_i(key) = (H(key) + d_i) \mod m \quad (i = 1, 2, \cdots, m-1)
$$

> 堆积: 不是同义词的关键字需要争夺同一个散列地址

##### 2. 二次探测法

> 二次探测法: 出现冲突时, 通过二次探测查找下一个空的散列地址, 公式为:

$$
H_i(key) = (H(key) + c_i \mod m) \quad (c_i = 1^2, -1^2, 2^2, -2^2, \cdots, q^2, -q^2, q \le \frac{m}{2})
$$

##### 3. 随机探测法

> 随机探测法: 出现冲突时, 通过随机探测查找下一个空的散列地址

#### 8.11.2 再散列法

> 再散列法: 当发生冲突时, 通过另一个散列函数重新计算散列地址

$$
H_i(key) = R(H(key)) \quad (i = 1, 2, \cdots, m-1)
$$

#### 8.11.3 链地址法

> 链地址法: 将所有散列到同一个地址的关键字存储在同一个链表中

#### 8.11.4 公共溢出区法

> 公共溢出区法: 将所有发生冲突的关键字存储在同一个溢出区中

### 8.12 散列表查找的实现

#### 8.12.1 散列表查找

相关常数和散列表结构定义:

```c
#define HASHSIZE 12
#define NULLKEY -32768

typedef struct {
    int *elem;
    int count;
} hashTable;
```

散列表初始化

```c
status initHashTable(hashTable *ht)
{
    int i;
    ht->count = HASHSIZE;
    ht->elem = (int *)malloc(HASHSIZE * sizeof(int));
    for (i = 0; i < HASHSIZE; i++) {
        ht->elem[i] = NULLKEY;
    }
    return OK;
}
```

散列函数

```c
int hash(int key)
{
    return key % HASHSIZE;
}
```

插入关键字

```c
void insertHash(hashTable *ht, int key)
{
    int addr = hash(key);
    while (ht->elem[addr] != NULLKEY) {
        addr = (addr + 1) % HASHSIZE;
    }
    ht->elem[addr] = key;
}
```

查找关键字

```c
status searchHash(hashTable ht, int key, int *addr)
{
    *addr = hash(key);
    while (ht.elem[*addr] != key) {
        *addr = (*addr + 1) % HASHSIZE;
        if (ht.elem[*addr] == NULLKEY || *addr == hash(key)) {
            return ERROR;
        }
    }
    return OK;
}
```

#### 8.12.2 散列表查找的性能分析

散列表查找的时间复杂度在没有冲突时为 $ O(1) $

影响散列表查找性能的因素:

1. 散列函数的设计
2. 处理冲突的方法
3. 散列表的装填因子: $ \alpha = \frac{n}{m} $, 其中 $n$ 为关键字个数, $m$ 为散列表长度, 装填因子越大, 冲突可能性越大, 查找时间越长

## 第九章 排序

### 9.2 排序的基本概念和分类

> 排序: 将一组无序的记录按照某种规则重新排列成有序的序列, 排序既可以按主关键字排序, 也可以按次关键字排序, 还可进行多关键字排序

#### 9.2.1 排序的稳定性

> 稳定性: 若两个记录的关键字相等, 在排序前后的相对位置不变, 则称排序是稳定的

#### 9.2.2 内排序和外排序

> 内排序: 待排序的所有记录全部存放在内存中进行排序
> 外排序: 待排序的记录太多, 无法同时存放在内存中, 需要借助外存进行排序

表现内排序性能的因素:

1. 时间复杂度: 受关键字比较次数和记录移动次数影响
2. 辅助空间复杂度: 受辅助空间大小影响
3. 算法的复杂性
4. 算法的稳定性

内排序的分类: 插入排序, 交换排序, 选择排序, 归并排序

#### 9.2.3 排序需要的结构和函数

排序用顺序表结构

```c
#define MAXSIZE 20
typedef struct {
    int r[MAXSIZE + 1];
    int length;
} sqList;
```

交换两个元素

```c
void swap(sqList *L, int i, int j)
{
    int temp = L->r[i];
    L->r[i] = L->r[j];
    L->r[j] = temp;
}
```

### 9.3 冒泡排序

> 冒泡排序: 一种交换排序, 通过相邻元素的比较和交换, 使得每次循环结束后最大的元素沉到最底部

```c
void bubbleSort(sqList *L)
{
    int i, j;
    for (i = 1; i < L->length; i++) {
        for (j = L->length - 1; j >= i; j--) {
            if (L->r[j] > L->r[j + 1]) {
                swap(L, j, j + 1);
            }
        }
    }
}
```

冒泡排序优化: 设置标志位, 若某次循环没有发生交换, 则说明序列已经有序, 可以提前结束

```c
void bubbleSort2(sqList *L)
{
    int i, j;
    int flag = TRUE;
    for (i = 1; i < L->length && flag; i++) {
        flag = FALSE;
        for (j = L->length - 1; j >= i; j--) {
            if (L->r[j] > L->r[j + 1]) {
                swap(L, j, j + 1);
                flag = TRUE;
            }
        }
    }
}
```

冒泡排序最好情况下为记录已经有序， 共需比较 $n-1$ 次， 时间复杂度为 $O(n)$,
 最坏情况下为记录逆序， 共需比较 $\frac{n(n-1)}{2}$ 次， 时间复杂度为 $O(n^2)$

### 9.4 简单选择排序

> 选择排序: 每次从待排序序列中选择最小的元素放在已排序序列的末尾
> 简单选择排序: 一种选择排序, 通过 $n-i$ 次关键字的比较, 从 $n-i+1$ 个记录中选出关键字最小的记录, 并和第 $i$ 个记录交换

```c
void simpleSelectSort(sqList *L)
{
    int i, j, min;
    for (i = 1; i < L->length; i++) {
        min = i;
        for (j = i + 1; j <= L->length; j++) {
            if (L->r[j] < L->r[min]) {
                min = j;
            }
        }
        if (i != min)
            swap(L, i, min);
    }
}
```

无论最好还是最坏情况下, 都需要进行 $\frac{n(n-1)}{2}$ 次比较,
 最好情况下, 即序列有序时不需要移动记录, 最坏情况下, 即序列逆序时需要移动 $n-1$ 次记录,
 故最好与最坏的时间复杂度均为 $O(n^2)$

### 9.5 直接插入排序

> 插入排序: 将一个记录插入到已经排好序的有序序列中, 使得插入后的序列仍然有序
> 直接插入排序: 一种插入排序, 将一个记录插入到已经排好序的有序序列中, 使得插入后的序列仍然有序

```c
void insertSort(sqList *L)
{
    int i, j;
    for (i = 2; i <= L->length; i++) {
        if (L->r[i] < L->r[i - 1]) {
            L->r[0] = L->r[i];
            for (j = i - 1; L->r[j] > L->r[0]; j--) {
                L->r[j + 1] = L->r[j];
            }
            L->r[j + 1] = L->r[0];
        }
    }
}
```

最好情况下, 即序列有序时, 只需进行 $n-1$ 次比较, 时间复杂度为 $O(n)$,
 最坏情况下, 即序列逆序时, 需要进行 $\sum_{i=2}^{n}i = \frac{(n+2)(n-1)}{2}$ 次比较, 另需移动 $\sum_{i=2}^{n}(i+1) = \frac{(n+4)(n-1)}{2}$ 次记录, 总的时间复杂度为 $O(n^2)$
 平均情况下, 比较和移动次数均约为 $\frac{n^2}{4}$, 时间复杂度为 $O(n^2)$

### 9.6 希尔排序

#### 9.6.1 希尔排序的原理

> 希尔排序: 一种插入排序, 通过增量序列 $d_1, d_2, \cdots, d_t$ 使得序列基本有序, 再进行直接插入排序

希尔排序的基本思路是: 由于直接插入排序在基本有序的情况下效率高,
 故先将整个待排序序列以相隔某个增量 $d$ 构成一个子序列的方式分割, 分别进行直接插入排序,
 待整个序列基本有序时, 再对全体记录进行一次直接插入排序

#### 9.6.2 希尔排序的实现

```c
void shellSort(sqList *L)
{
    int i, j;
    int increment = L->length;
    do {
        increment = increment / 3 + 1;
        for (i = increment + 1; i <= L->length; i++) {
            if (L->r[i] < L->r[i - increment]) {
                L->r[0] = L->r[i];
                for (j = i - increment; j > 0 && L->r[0] < L->r[j]; j -= increment) {
                    L->r[j + increment] = L->r[j];
                }
                L->r[j + increment] = L->r[0];
            }
        }
    } while (increment > 1);
}
```

增量序列的选择对希尔排序的性能影响较大, 一般情况下,
 增量序列为 $d_k = 2^{t-k+1}-1 \quad (0 \le k \le t-1 \le \left \lfloor \log_2 n \right \rfloor)$, 且需满足 $d_t = 1$

#### 9.6.3 希尔排序的性能分析

希尔排序的时间复杂度与增量序列有关,
 增量序列为上述的 $d_k = 2^{t-k+1}-1$ 时,
 希尔排序的时间复杂度为 $O(n^{\frac{3}{2}})$

### 9.7 堆排序

> 堆: 是一种完全二叉树, 其中每个结点的值都大于或等于其左右孩子结点的值, 称为大顶堆, 反之称为小顶堆

堆结点之间满足如下关系 (此处为大顶堆):

$$
r[i] \ge r[2i] \quad \text{且} \quad r[i] \ge r[2i+1] \quad (1 \le i \le \frac{n}{2})
$$

#### 9.7.1 堆排序算法

> 堆排序: 通过构建大顶堆, 使得堆顶元素为最大值, 将堆顶元素与堆尾元素交换, 重新调整堆, 使得堆顶元素为次大值, 重复此过程直至堆为空

```c
void heapSort(sqList *L)
{
    int i;
    for (i = L->length / 2; i > 0; i--) {   // build heap
        heapAdjust(L, i, L->length);
    }
    for (i = L->length; i > 1; i--) {       // sort
        swap(L, 1, i);
        heapAdjust(L, 1, i - 1);
    }
}

void heapAdjust(sqList *L, int s, int m)
{
    int temp, j;
    temp = L->r[s];
    for (j = 2 * s; j <= m; j *= 2) {
        if (j < m && L->r[j] < L->r[j + 1]) {
            j++;
        }
        if (temp >= L->r[j]) {
            break;
        }
        L->r[s] = L->r[j];
        s = j;
    }
    L->r[s] = temp;
}
```

#### 9.7.2 堆排序的性能分析

建堆的时间复杂度为 $O(n)$, 调整堆的时间复杂度为 $O(n \log n)$,
 故堆排序的时间复杂度为 $O(n \log n)$

### 9.8 归并排序

#### 9.8.1 归并排序算法

> 2 路归并排序: 首先将序列中的元素两两归并, 得到 $n/2$ 个有序的子序列, 再将这些子序列两两归并, 递归进行, 直至得到一个有序序列

```c
void mergeSort(sqList *L)
{
    mSort(L, L->r, 1, L->length);
}

void mSort(sqList *L, int sr[], int low, int high)
{
    int m;
    int tr[MAXSIZE + 1];

    if (low == high) {
        sr[low] = L->r[low];
    } else {
        m = (low + high) / 2;
        mSort(L, sr, low, m);
        mSort(L, sr, m + 1, high);
        merge(sr, tr, low, m, high);
    }
}

void merge(int sr[], int tr[], int i, int m, int n)
{
    int j, k, l;
    for (j = m + 1, k = i; i <= m && j <= n; k++) {
        if (sr[i] < sr[j]) {
            tr[k] = sr[i++];
        } else {
            tr[k] = sr[j++];
        }
    }
    if (i <= m) {
        for (l = 0; l <= m - i; l++) {
            tr[k + l] = sr[i + l];
        }
    }
    if (j <= n) {
        for (l = 0; l <= n - j; l++) {
            tr[k + l] = sr[j + l];
        }
    }
}
```

#### 9.8.2 归并排序的性能分析

归并排序的时间复杂度为 $O(n \log n)$

空间复杂度为 $O(n + \log n)$

#### 9.8.3 归并排序的非递归实现

```c
void mergeSort2(sqList *L)
{
    int len = 1;
    int *temp = (int *)malloc(L->length * sizeof(int));
    while (len < L->length) {
        mergePass(L->r, temp, len, L->length);
        len *= 2;
        mergePass(temp, L->r, len, L->length);
        len *= 2;
    }
    free(temp);
}

void mergePass(int sr[], int tr[], int len, int n)
{
    int i = 1;
    int j;
    while (i <= n - 2 * len + 1) {
        merge(sr, tr, i, i + len - 1, i + 2 * len - 1);
        i += 2 * len;
    }
    if (i < n - len + 1) {
        merge(sr, tr, i, i + len - 1, n);
    } else {
        for (j = i; j <= n; j++) {
            tr[j] = sr[j];
        }
    }
}
```

非递归实现的归并排序的时间复杂度为 $O(n \log n)$ 但比递归实现的归并排序效率更高

空间复杂度为 $O(n)$

### 9.9 快速排序

#### 9.9.1 快速排序算法

> 快速排序: 通过一趟排序将待排序序列分割成独立的两部分, 其中一部分的所有元素均小于另一部分的所有元素, 再分别对这两部分进行排序

```c
void quickSort(sqList *L)
{
    qSort(L, 1, L->length);
}

void qSort(sqList *L, int low, int high)
{
    int pivot;
    if (low < high) {
        pivot = partition(L, low, high);
        qSort(L, low, pivot - 1);
        qSort(L, pivot + 1, high);
    }
}

int partition(sqList *L, int low, int high)
{
    int pivotkey = L->r[low];

    while (low < high) {
        while (low < high && L->r[high] >= pivotkey)
            high--;
        swap(L, low, high);
        while (low < high && L->r[low] <= pivotkey)
            low++;
        swap(L, low, high);
    }
    return low;
}
```

#### 9.9.2 快速排序的性能分析

快速排序的一般时间复杂度为 $O(n \log n)$

最好情况下, 即每次划分都能将序列分为两个长度相等的子序列, 时间复杂度为 $O(n \log n)$

最坏情况下， 即原序列有序时， 每次划分只能将序列分为一个长度为 $n-1$ 的子序列和一个长度为 $0$ 的子序列， 时间复杂度为 $O(n^2)$

空间复杂度为 $O(\log n)$

#### 9.9.3 快速排序的优化

##### 1. 优化选取枢轴

1. 随机选取法: 随机选取序列中的一个元素作为枢轴
2. 三数取中法: 选取序列的头、尾、中间三个元素的中位数作为枢轴
3. 九数取中法: 三数取中法的升级版，适用于大数组

##### 2. 优化不必要的交换

```c
int partition2(sqList *L, int low, int high)
{
    int pivotkey;
    int temp = L->r[low];

    int m = low + (high - low) / 2; // three number median
    if (L->r[low] > L->r[high]) {
        swap(L, low, high);
    }
    if (L->r[m] > L->r[high]) {
        swap(L, m, high);
    }
    if (L->r[m] > L->r[low]) {
        swap(L, m, low);
    }

    pivotkey = L->r[low];
    while (low < high) {
        while (low < high && L->r[high] >= pivotkey)
            high--;
        L->r[low] = L->r[high];
        while (low < high && L->r[low] <= pivotkey)
            low++;
        L->r[high] = L->r[low];
    }
    L->r[low] = pivotkey;
    return low;
}
```

##### 3. 优化小数组的排序

对于小数组， 可以使用插入排序代替快速排序

```c
#define MAX_INSERT_LENGTH 7 // 50 is another choice
void qSort2(sqList *L, int low, int high)
{
    int pivot;
    if (high - low > MAX_INSERT_LENGTH) {
        pivot = partition2(L, low, high);
        qSort2(L, low, pivot - 1);
        qSort2(L, pivot + 1, high);
    } else {
        insertSort(L);
    }
}
```

##### 4. 优化递归

对于递归的优化， 可以使用尾递归或者非递归的方式

```c
void qSort3(sqList *L, int low, int high)
{
    int pivot;
    while (low < high) {
        pivot = partition2(L, low, high);
        qSort3(L, low, pivot - 1);
        low = pivot + 1;
    }
}
```

### 9.10 总结

7 种排序算法的比较:

|   排序算法   |   分类   |         平均情况          |   最坏情况    |   最好情况    |  稳定性  |      空间复杂度       |
| :----------: | :------: | :-----------------------: | :-----------: | :-----------: | :------: | :-------------------: |
|   冒泡排序   | 交换排序 |         $O(n^2)$          |   $O(n^2)$    |    $O(n)$     |    是    |        $O(1)$         |
| 简单选择排序 | 选择排序 |         $O(n^2)$          |   $O(n^2)$    |   $O(n^2)$    | 一般为否 |        $O(1)$         |
| 直接插入排序 | 插入排序 |         $O(n^2)$          |   $O(n^2)$    |    $O(n)$     |    是    |        $O(1)$         |
|   希尔排序   | 插入排序 | $O(n \log n) \sim O(n^2)$ | $O(n^{1.3})$  |   $O(n^2)$    |    否    |        $O(n)$         |
|    堆排序    | 选择排序 |       $O(n \log n)$       | $O(n \log n)$ | $O(n \log n)$ |    否    |        $O(1)$         |
|   归并排序   | 归并排序 |       $O(n \log n)$       | $O(n \log n)$ | $O(n \log n)$ |    是    |        $O(n)$         |
|   快速排序   | 交换排序 |       $O(n \log n)$       |   $O(n^2)$    | $O(n \log n)$ |    否    | $O(\log n) \sim O(n)$ |

三种简单排序的移动次数复杂度:

|   排序算法   | 平均情况 | 最坏情况 | 最好情况 |
| :----------: | :------: | :------: | :------: |
|   冒泡排序   | $O(n^2)$ | $O(n^2)$ |    0     |
| 简单选择排序 |  $O(n)$  |  $O(n)$  |    0     |
| 直接插入排序 | $O(n^2)$ | $O(n^2)$ |  $O(n)$  |
