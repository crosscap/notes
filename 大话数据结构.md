# 第一章 数据结构绪论

## 1.4 基本概念和术语

### 1.4.1 数据

### 1.4.2 数据元素

### 1.4.3 数据项

### 1.4.4 数据对象

### 1.4.5 数据结构

## 1.5 逻辑结构与物理结构

### 1.5.1 逻辑结构

1. 集合结构
2. 线性结构
3. 树形结构
4. 图形结构

### 1.5.2 物理结构（存储结构）

1. 顺序存储结构
2. 链式存储结构

## 1.6 数据类型

### 1.6.1 数据类型定义

### 1.6.2 抽象数据类型

抽象数据类型(ADT): 一个数学模型及定义在该模型上的一组操作.

```ADT
ADT 抽象数据类型名
Data

Operation
    操作1
        初始条件
        操作结果描述
endADT
```

注: 本书中使用C语言实现数据类型, 在ADT中, 改变数据类型本身的情况使用类似传址方式表示如 `*S`, 不改变数据类型本身的情况使用类似传值方式表示如 `S`, 但对于顺序存储结构实现, 传递参数时为保证效率, 不论是否改变数据类型本身一般都以传址方式实现, 此时不改变数据类型本身的情况使用 `const` 限定, 而对于链式存储结构与 ADT 中的表示相同

# 第二章 算法

## 2.4 算法定义

## 2.5 算法的特性

1. 输入输出
2. 有穷性
3. 确定性
4. 可行性

## 2.6 算法设计的要求

1. 正确性
2. 可读性
3. 健壮性
4. 时间效率高和存储量低

## 2.7 算法效率的度量方法

### 2.7.1 事后统计方法

### 2.7.2 事前分析估算方法

高级语言编写的程序运行时消耗的时间的影响因素：

1. **算法采用的策略、方法**
2. 编译产生的代码质量
3. **问题的输入规模**
4. 机器执行指令的速度

## 2.8 函数的渐近增长

判断一个函数的效率时，函数中的常数和其他次要项常常可以忽略，而应该关注主项（最高阶项）的项数

## 2.9 算法时间复杂度

### 2.9.1 算法时间复杂度定义

$ T(n) = O(f(n)) $

### 2.9.2 推导大O阶方法

### 2.9.3 常数阶

### 2.9.4 线性阶

### 2.9.5 对数阶

### 2.9.6 平方阶

## 2.10 常见的时间复杂度

$ O(1) < O(\log{n}) < O(n\log{n}) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n) $

## 2.11 最坏情况与平均情况

一般计算最坏情况运行时间即**最坏时间复杂度**

平均运行时间代表了期望的运行时间即**平均时间复杂度**

## 2.12 算法空间复杂度

$ S(n) = O(f(n)) $

# 第三章 线性表

## 3.2 线性表的定义

> 线性表 (List): 零个或多个数据元素的有限序列。

## 3.3 线性表的抽象数据类型

```ADT
ADT 线性表 (List)
Data

Operation
    init_list(*L)
    list_empty(L)
    clear_list(*L)
    get_elem(L, i, *e)
    locate(L, e)
    list_insert(*L, i, e)
    list_delete(*L, i, *e)
    list_length(L)
endADT
```

计算集合 $ A = A \cup B $, 使用 `La` 表示集合 $ A $, `Lb` 表示集合 $ B $

```C
void union(sqList *La, sqList Lb)
{
    int La_len, Lb_len, i;
    ElemType e;
    La_len = list_length(*La);
    Lb_len = list_length(Lb);
    for (i = 1; i <= Lb_len; i++) {
        GetElem(Lb, i, &e);
        if (!locate_elem(*La, e))
            list_insert(La, ++La_len, e);
    }
}
```

## 3.4 线性表的顺序存储结构

### 3.4.1 顺序存储定义

> 用一段连续的存储单元依次存储线性表的数据元素

### 3.4.2 顺序存储方式

```C
#define MAXSIZE 20
typedef int elemType;
typedef struct {
    elemType data[MAXSIZE];
    int length;
} sqList;
```

### 3.4.3 数组长度与线性表长度的区别

#### 数组长度

存放线性表的储存空间的长度，储存分配后一般不变。

#### 线性表长度

线性表中数据元素的个数，随插入和删除操作而发生变化

在任意时刻，线性表的长度小于等于数组的长度

### 3.4.4 地址的计算方法

线性表的第 $ i $ 个元素存放在数组下标为 $ i - 1 $ 的位置

线性表中元素的储存位置之间的关系

$$ LOC(a_{i+1}) = LOC(a_{i}) + c $$

可推得

$$ LOC(a_{i}) = LOC(a_{1}) + (i - 1) * c $$

存取性能为 $ O(1) $ 称之为随机存取结构.

## 3.5 顺序存储结构的插入与删除

### 3.5.1 获得元素操作

```C
#define OK 1
#define ERROR 0
typedef int status;
status get_elem(const sqList *L, int i, elemType *e)
{
    if (L->length == 0 || i < 1 || i > L->length)
        return ERROR;
    *e = L->data[i - 1];

    return OK;
}
```

### 3.5.2 插入操作

```c
status list_insert(sqList *L, int i, elemType e)
{
    int k;

    if (L->length == MAXSIZE)
        return ERROR;
    if (i < 1 || i > L->length + 1)
        return ERROR;
    if (i <= L->length) {
        for (k = L->length - 1; k >= i - 1; --k)
            L->data[k + 1] = L->data[k];
    L->data[i - 1] = e;
    ++L->length;

    return OK;
    }
}
```

### 3.5.3 删除操作

```c
status list_delete(sqList *L, int i, elemType *e)
{
    int k;

    if (L->length == 0)
        return ERROR;
    if (i < 1 || i > L->length + 1)
        return ERROR;
    *e = L->data[i - 1];
    if (i < L->length) {
        for (k = i; k < L->length; ++k)
            L->data[k - 1] = L->data[k];
    }
    --L->length;

    return OK;
}
```

插入和删除操作的时间复杂度分析

最好情况: 插入或者删除最后一个位置时为 $ O(1) $

最坏情况: 插入或者删除第一个位置时为 $ O(n) $

平均情况:

$$ \sum_{i = 1}^{n}\frac{1}{n}(n - i + 1) = \frac{n - 1}{2} $$

故平均时间复杂度为 $ O(n) $

### 3.5.4 线性表顺序存储结构的优缺点

- 优点
    - 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
    - 可以快速地存取表中任意位置的元素
- 缺点
    - 插入和删除操作需要移动大量的元素
    - 当线性表长度变化较大时, 难以确定存储空间的容量
    - 造成存储空间的碎片

## 3.6 线性表的链式存储结构

### 3.6.1 顺序存储结构不足的解决办法

### 3.6.2 线性表链式存储结构定义

- 结点
    - 数据域
    - 指针域

链式存储结构: n个结点链接成一个链表

头结点: 有的链表为方便操作, 会在第一个结点前附设一个结点, 头结点数据域内可以不储存任何数据

头指针: 无头结点时为链表中第一个结点的存储位置, 有头结点时为指向头结点的指针

### 3.6.3 线性表链式存储结构代码描述

```c
typedef struct node {
    elemType data;
    struct node *next;
} node;
typedef struct node *linkList;
```

## 3.7 单链表的读取

```c
status get_elem(linkList L, int i, elemType *e)
{
    int j = 1;
    node *p = L->next;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR;
    *e = p->data;
    return OK;
}
```

最坏时间复杂度为 $ O(n) $

## 3.8 单链表的插入与删除

### 3.8.1 单链表的插入

将结点 `s` 插入到 `p` 与 `p->next` 之间

```c
s->next = p->next;
p->next = s;
```

注意: 上述语句的顺序不可颠倒

```c
status list_insert(linkList *L, int i, elemType e)
{
    int j = 1;
    node *s;
    node *p = *L;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR;
    s = (linkList)malloc(sizeof(node));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}
```

### 3.8.2 单链表的删除

```c
q = p->next;
p->next = q->next;
free(q);
```

代码如下

```c
status list_delete(linkList *L, int i, elemType *e)
{
    int j = 1;
    node *q;
    node *p = *L;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR;
    q = p->next;
    p->next = q->next;
    *e = q->data;
    free(q);
    return OK;
}
```

插入和删除的时间复杂度均为 $ O(n) $

但若需插入的结点 (或者此结点的前置结点) 的位置已知则时间复杂度为 $ O(1) $

## 3.9 单链表的整表创建

头插法

```c
void create_list_head(linkList *L, int n)
{
    node *p;
    int i;
    *L = (linkList)malloc(sizeof(node));
    (*L)->next = NULL;
    for (i = 0; i < n; ++i) {
        p = (linkList)malloc(sizeof(node));
        p->data = i;
        p->next = (*L)->next;
        (*L)->next = p;
    }
}
```

尾插法

```c
void create_list_tail(linkList *L, int n)
{
    node *p;
    node *r;
    int i;
    *L = (linkList)malloc(sizeof(node));
    r = *L;
    for (i = 0; i < n; ++i) {
        p = (linkList)malloc(sizeof(node));
        p->data = i;
        r->next = p;
        r = p;
    }
    r->next = NULL;
}
```

## 3.10 单链表的整表删除

```c
void clear_list(linkList *L)
{
    node *p, *q;
    p = (*L)->next;
    (*L)->next = NULL;
    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    return OK;
}
```

## 3.11 单链表结构与顺序存储结构的优缺点

## 3.12 静态链表

在早期的没有指针的编程语言中, 用数组描述链表

静态链表结构

```c
#define MAXSIZE 1000
#define HEAD (MAXSIZE - 1)

typedef struct {
    elemType data;
    int cur;
} component, staticLinkList[MAXSIZE];
```

创建静态链表

```c
status init_list(staticLinkList space)
{
    int i;
    for (i = 0; i < HEAD; ++i)
        space[i].cur = i + 1;
    space[HEAD].cur = 0;
    return OK;
}
```

### 3.12.1 静态链表的插入

分配空闲的结点

```c
int malloc_SSL(staticLinkList space)
{
    int i = space[HEAD].cur;
    if (i)
        space[HEAD].cur = space[i].cur;
    return i;
}
```

静态链表的插入

```c
status list_insert(staticLinkList L, int i, elemType e)
{
    int j, k, l;

    if (i < 1 || i > list_length(L) + 1)
        return ERROR;
    j = malloc_SSL(L);
    if (j) {
        L[j].data = e;
        for (l = 0, k = HEAD; l < i - 1; ++l)
            k = L[k].cur;
        L[j].cur = L[k].cur;
        L[k].cur = j;
        return OK;
    }
}
```

### 3.12.2 静态链表的删除

释放不使用的结点

```c
void free_SSL(staticLinkList space, int i)
{
    space[i].cur = space[0].cur;
    space[0].cur = i;
}
```

静态链表的删除

```c
status list_delete(staticLinkList L, int i, elemType *e)
{
    int j, k;

    if (i < 1 || i > list_length(L))
        return ERROR;
    for (k = HEAD, j = 0; j < i - 1; ++j)
        k = L[k].cur;
    j = L[k].cur;
    L[k].cur = L[j].cur;
    *e = L[j].data;
    free_SSL(L, j);
    return OK;
}
```

另有其他操作, 如list_length

```c
int list_length(staticLinkList L)
{
    int j = 0;
    int i = L[HEAD].cur;
    while (i) {
        i = L[i].cur;
        ++j;
    }
    return j;
}
```

### 3.12.3 静态链表的优缺点

## 3.12 循环链表

单循环链表中为使得到最后一节点的时间复杂度为 $ O(1) $ 使用指向终端结点的尾指针 `rear` 代替头指针

查找头结点 `rear->next`

查找开始结点 `rear->next->next`

有头结点的循环链表判断是否为空表

```c
status list_empty(linkList rear) {
    return rear->next == rear;
}
```

合并两个循环链表

```c
void merge_cycle_list(linkList rearA, linkList rearB) {
    node *p, *q;

    p = rearA->next;
    rearA->next = rearB->next->next;
    q = rearB->next;
    rearB->next = p;
    free(q);
}
```

## 3.13 双向链表

在单链表中, 再设置一个指向前驱结点的指针域

```c
typedef struct dulNode {
    elemType data;
    struct dulNode *prior, *next;
} dulNode, dulLinkList;
```

双链表也可设置为循环双链表

有头结点的双链表判断是否为空表

```c
status list_empty(dulLinkList L) {
    return L->next == NULL;
}
```

有头结点的双循环链表判断是否为空表

```c
status list_empty(dulLinkList L) {
    return L->next == L;
}
```

双链表的插入 (s为待插入结点, 插入到p结点之后)

```c
s->prior = p;
s->next = p->next;
p->next->prior = s;
p->next = s;
```

1, 2顺序可颠倒, 但是其他的顺序不可改变

双链表的删除

```c
p->prior->next = p->next;
p->next->prior = p->prior;
free(p);
```

# 第四章 栈与队列

## 4.2 栈的定义

### 4.2.1 栈的定义

栈: 限定仅在表尾进行插入和删除操作的线性表, 又称为后进先出 (Last In First Out) 线性表, 简称LIFO结构

允许进行插入删除操作的一端 (表尾) 称为栈顶 (Top) , 另一端称为栈底 (Bottom)

栈的插入操作称为进栈 (Push)

栈的删除操作称为出栈 (Pop)

### 4.2.2 进栈出栈的变化形式

## 4.3 栈的抽象数据类型

```ADT
ADT 栈 (Stack)
Data
    同线性表
Operation
    init_stack(*S)
    destroy_stack(*S)
    clear_stack(*S)
    stack_empty(S)
    get_top(S, *e)
    push(*S, e)
    pop(*S, *e)
    stack_length(S)
endADT
```

## 4.4 栈的顺序存储结构及实现

### 4.4.1 栈的顺序储存结构

顺序栈: 顺序表的简化, 使用下标0的一端作栈底

顺序栈的结构定义

```c
typedef struct {
    elemType data[MAXSIZE];
    int top;
} sqStack;
```

顺序栈的栈空判定

```c
status stack_empty(const sqStack *S)
{
    if (S->top == -1) {
        return OK;
    } else {
        return ERROR;
    }
}
```

### 4.4.2 进栈操作

顺序栈的进栈

```c
status push(sqStack *S, elemType e)
{
    if (S->top == MAXSIZE - 1) {
        return ERROR;
    }
    S->top++;
    S->data[S->top] = e;
    return OK;
}
```

### 4.4.3 出栈操作

顺序栈的出栈

```c
status pop(sqStack *S, elemType *e)
{
    if (S->top == -1) {
        return ERROR;
    }
    *e = S->data[S->top];
    S->top--;
    return OK;
}
```

出栈入栈时间复杂度均为 $ O(1) $

## 4.5 两栈共享空间

## 4.6 栈的链式存储结构及实现

### 4.6.1 栈的链式存储结构

链栈: 链表的简化, 表头作栈顶, 且一般不需要头结点

链栈的结构定义

```c
typedef struct node {
    elemType data;
    struct node *next;
} node, *linkStackPtr;

typedef struct {
    linkStackPtr top;
    int count;
} linkStack;
```

链栈的栈空判定

```c
status stack_empty(linkStack *S)
{
    if (S->top == NULL) {
        return OK;
    } else {
        return ERROR;
    }
}
```

### 4.6.2 进栈操作

链栈的进栈

```c
status push(linkStack *S, elemType e)
{
    node *s = (node*)malloc(sizeof(node));

    s->data = e;
    s->next = S->top;
    S->top = s;
    S->count++;
    return OK;
}
```

### 4.6.3 出栈操作

链栈的出栈

```c
status pop(linkStack *S, elemType *e)
{
    node *p = S->top;

    if (S->top == NULL) {
        return ERROR;
    }
    *e = p->data;
    S->top = p->next;
    free(p);
    S->count--;
    return OK;
}
```

出栈入栈时间复杂度均为 $ O(1) $

## 4.7 栈的作用

栈的引入简化了程序设计的问题, 划分了不同关注层次, 使得思考范围缩小, 更加聚焦于要解决的问题核心.

## 4.8 栈的应用--递归

### 4.8.1 斐波那契数列的实现

迭代法

```c
int fibonacci_iter(int n)
{
    int i;
    int fibo[100];
    fibo[0] = 0;
    fibo[1] = 1;
    for (i = 2; i <= n; ++i) {
        fibo[i] = fibo[i - 1] + fibo[i - 2];
    }
    return fibo[n];
}
```

递归法

```c
int fibonacci_recu(int n)
{
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci_recu(n - 1) + fibonacci_recu(n - 2);
    }
}
```

### 4.8.2 递归的定义

递归函数: 直接调用自己或者经过一系列调用语句间接调用自己的函数

递归过程中先进行前行的递归调用, 随后又以前行顺序的逆序进行退回, 退回过程中可能需要恢复前行过程中的某些数据以执行某些动作, 故编译器使用栈实现递归

在前行阶段, 每一层递归对应的函数的局部变量, 参数值, 返回地址都被压入栈中, 回退阶段依次弹出进行恢复

## 4.9 栈的应用--四则运算表达式求值

### 4.9.1 后缀 (逆波兰) 表示法的定义

后缀表示法: 符号在要运算的数字后出现, 不需要使用括号和优先级限定运算顺序

对应的, 传统的标准四则运算表达式称为中缀表达式

### 4.9.2 后缀表达式的计算结果

运算方法:

```Pseudocode
从左到右遍历后缀表达式,

    遇到数字则进栈;

    遇到运算符则将栈顶的两个数字弹栈, 第一个出栈的位于运算符右侧, 第二个出栈的位于运算符左侧, 完成相应运算后计算结果进栈,

直至遍历完成, 将最终结果弹栈.
```

### 4.9.3 中缀表达式转后缀表达式

转换方法:

```pesudocode
从左到右遍历中缀表达式,

    遇到数字则输出;

    遇到左括号则进栈;

    遇到右括号则将栈中运算符依次出栈并输出, 直至遇到左括号将其仅出栈不输出;

    遇到运算符则判断其与栈顶运算符的优先级,

        如果为空栈或栈顶为左括号( 则直接入栈;

        如果当前运算符优先级高于栈顶运算符则当前运算符入栈;

        如果当前运算符优先级不高于 (<=) 栈顶运算符, 则将栈中元素出栈并输出, 继续将当前运算符同栈顶运算符进行下一次比较;

继续遍历中缀表达式, 最终遍历完成中缀表达式, 将剩余栈中运算符依次弹栈输出, 完成转化
```

运算符等级 (从高到低) :

\* /

\+ \-

## 4.10 队列的定义

队列: 限定仅在表尾进行插入, 仅在表头进行删除操作的线性表, 又称为先进先出 (First In First Out) 线性表, 简称FIFO结构

允许进行插入操作的一端 \(表尾\) 称为队尾, 允许进行删除操作的一端 \(表头\) 称为队头

队列的插入操作称为入队, 删除操作称为出队

## 4.11 队列的抽象数据类型

```ADT
ADT 队列 (Queue)
Data
    同线性表
Operation
    init_queue(*Q)
    destroy_queue(*Q)
    clear_queue(*Q)
    queue_empty(Q)
    get_head(Q, *e)
    enqueue(*Q, e)
    dequeue(*Q, *e)
    queue_length(Q)
endADT
```

## 4.12 循环队列

### 4.12.1 队列顺序存储的不足

### 4.12.2 循环队列的定义

`front`指向队头元素, `rear`指向队尾元素的下一个位置

队满条件 (使用`flag`, 使最大储存量为`MAXSIZE`):
` (rear + 1) % queueSize == front && flag == 1 `

队满条件 (不使用`flag`, 使最大储存量为`MAXSIZE - 1`):
` (rear + 1) % queueSize == front `

主要采用不使用`flag`的版本

队列长度:
` (rear - front + queueSize) % queueSize `

顺序存储结构代码:

```c
typedef struct {
    elemType data[MAXSIZE];
    int front;
    int rear;
} sqQueue;
```

初始化循环队列:

```c
status init_queue(sqQueue *Q)
{
    Q->front = 0;
    Q->rear = 0;
    return OK;
}
```

循环队列判空:

```c
int queue_empty(const sqQueue *Q)
{
    return Q->front == Q->rear;
}
```

循环队列判满:

```c
int queue_full(const sqQueue *Q)
{
    return (Q->rear + 1) % MAXSIZE == Q->front;
}
```

循环队列长度:

```c
int queue_length(const sqQueue *Q)
{
    return (Q->rear - Q->front + MAXSIZE) % MAXSIZE;
}
```

循环队列入列:

```c
status enqueue(sqQueue *Q, elemType e)
{
    if ((Q->rear + 1) % MAXSIZE == Q->front) {
        return ERROR;
    }
    Q->data[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXSIZE;
    return OK;
}
```

循环队列出列:

```c
status dequeue(sqQueue *Q, elemType *e)
{
    if (Q->front == Q->rear) {
        return ERROR;
    }
    *e = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;

    return OK;
}
```

出队入队时间复杂度均为 $ O(1) $

## 4.13 队列的链式存储结构及实现

链队列: 链表的简化, 且一般需要头结点, 头节点的 `next` 指针指向队头

空队列时, `front` 和 `rear` 均指向头结点

链队列的结构定义:

```c
typedef struct node {
    elemType data;
    struct node *next;
} node;
typedef node *queuePtr;

typedef struct {
    queuePtr front;
    queuePtr rear;
} linkQueue;
```

### 4.13.1 入队操作

链队列的入队:

```c
status enqueue(linkQueue *Q, elemType e)
{
    queuePtr p = (queuePtr)malloc(sizeof(node));
    if (!p) {
        exit(OVERFLOW);
    }
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = p;
    return OK;
}
```

### 4.13.2 出队操作

链队列的出队:

```c
status dequeue(linkQueue *Q, elemType *e)
{
    queuePtr p;
    if (Q->front == Q->rear) {
        return ERROR;
    }
    p = Q->front->next;
    *e = p->data;
    Q->front->next = p->next;
    if (Q->rear == p) {
        Q->rear = Q->front;
    }
    free(p);
    return OK;
}
```

# 第五章 串

## 5.2 串的定义

串: 由零个或多个字符组成的有限序列, 又叫字符串

空串:

子串与主串:

子串在主串中的位置:

## 5.3 串的比较

字符比较: 比较两字符的编码值 (ASCII, Unicode)

串相等: 串的长度和各个位置对应的字符都相等

串大小判断 (字典序) :

逐个比较两串 $ s $ 与 $ t $ 各个位置字符的大小, 当出现不同时, 字符小的对应的串小, 若直至某一串被遍历完未发现字符不同, 被遍历完成的串小 (长度短的字符串小), 都被遍历完成则两串相等

## 5.4 串的抽象数据类型

串的逻辑结构同线性表相似, 但所含元素和主要操作不同

```ADT
ADT 串 (string)
Data
    串中元素仅由字符组成, 相邻元素具有前驱和后继关系
Operation
    str_assign(*T, *chars)
    str_copy(*T, S)
    str_length(S)
    str_compare(S, T)
    str_concat(*T, S1, S2)
    sub_string(*Sub, S, pos, len)
    str_insert(*T, pos, S)
    str_delete(*T, pos, len)
    str_replace(*T, S, V)
    str_index(S, T, pos)
    clear_string(*S)
endADT
```

`str_index` 操作的实现

```c
int std_index(string s, string t, int pos)
{
    int n, m, i;
    string sub;

    if (pos > 0) {
        n = str_length(s);
        m = str_length(t);
        i = pos;
        while (i <= n - m + 1) {
            sub_string(sub, s, i, m);
            strncpy(sub, s + i - 1, m);
            if (str_compare(sub, t) != 0) {
                ++i;
            } else {
                return i;
            }
        }
    }

    return 0;
}
```
