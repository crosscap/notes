# 大话数据结构

## 第一章 数据结构绪论

### 1.4 基本概念和术语

#### 1.4.1 数据

#### 1.4.2 数据元素

#### 1.4.3 数据项

#### 1.4.4 数据对象

#### 1.4.5 数据结构

### 1.5 逻辑结构与物理结构

#### 1.5.1 逻辑结构

1. 集合结构
2. 线性结构
3. 树形结构
4. 图形结构

#### 1.5.2 物理结构（存储结构）

1. 顺序存储结构
2. 链式存储结构

### 1.6 数据类型

#### 1.6.1 数据类型定义

#### 1.6.2 抽象数据类型

抽象数据类型(ADT): 一个数学模型及定义在该模型上的一组操作.

```ADT
ADT 抽象数据类型名
Data

Operation
    操作1
        初始条件
        操作结果描述
endADT
```

注: 本书中使用C语言实现数据类型, 在ADT中, 改变数据类型本身的情况使用类似传址方式表示如 `*S`, 不改变数据类型本身的情况使用类似传值方式表示如 `S`, 但对于顺序存储结构实现, 传递参数时为保证效率, 不论是否改变数据类型本身一般都以传址方式实现, 此时不改变数据类型本身的情况使用 `const` 限定, 而对于链式存储结构与 ADT 中的表示相同

## 第二章 算法

### 2.4 算法定义

### 2.5 算法的特性

1. 输入输出
2. 有穷性
3. 确定性
4. 可行性

### 2.6 算法设计的要求

1. 正确性
2. 可读性
3. 健壮性
4. 时间效率高和存储量低

### 2.7 算法效率的度量方法

#### 2.7.1 事后统计方法

#### 2.7.2 事前分析估算方法

高级语言编写的程序运行时消耗的时间的影响因素：

1. **算法采用的策略、方法**
2. 编译产生的代码质量
3. **问题的输入规模**
4. 机器执行指令的速度

### 2.8 函数的渐近增长

判断一个函数的效率时，函数中的常数和其他次要项常常可以忽略，而应该关注主项（最高阶项）的项数

### 2.9 算法时间复杂度

#### 2.9.1 算法时间复杂度定义

$ T(n) = O(f(n)) $

#### 2.9.2 推导大O阶方法

#### 2.9.3 常数阶

#### 2.9.4 线性阶

#### 2.9.5 对数阶

#### 2.9.6 平方阶

### 2.10 常见的时间复杂度

$$
O(1) < O(\log{n}) < O(n\log{n}) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
$$

### 2.11 最坏情况与平均情况

一般计算最坏情况运行时间即**最坏时间复杂度**

平均运行时间代表了期望的运行时间即**平均时间复杂度**

### 2.12 算法空间复杂度

$ S(n) = O(f(n)) $

## 第三章 线性表

### 3.2 线性表的定义

> 线性表 (List): 零个或多个数据元素的有限序列。

### 3.3 线性表的抽象数据类型

```ADT
ADT 线性表 (List)
Data

Operation
    init_list(*L)
    list_empty(L)
    clear_list(*L)
    get_elem(L, i, *e)
    locate(L, e)
    list_insert(*L, i, e)
    list_delete(*L, i, *e)
    list_length(L)
endADT
```

计算集合 $ A = A \cup B $, 使用 `La` 表示集合 $ A $, `Lb` 表示集合 $ B $

```C
void union(sqList *La, sqList Lb)
{
    int La_len, Lb_len, i;
    ElemType e;
    La_len = list_length(*La);
    Lb_len = list_length(Lb);
    for (i = 1; i <= Lb_len; i++) {
        GetElem(Lb, i, &e);
        if (!locate_elem(*La, e))
            list_insert(La, ++La_len, e);
    }
}
```

### 3.4 线性表的顺序存储结构

#### 3.4.1 顺序存储定义

> 用一段连续的存储单元依次存储线性表的数据元素

#### 3.4.2 顺序存储方式

```C
#define MAXSIZE 20
typedef int elemType;
typedef struct {
    elemType data[MAXSIZE];
    int length;
} sqList;
```

#### 3.4.3 数组长度与线性表长度的区别

##### 数组长度

存放线性表的储存空间的长度，储存分配后一般不变。

##### 线性表长度

线性表中数据元素的个数，随插入和删除操作而发生变化

在任意时刻，线性表的长度小于等于数组的长度

#### 3.4.4 地址的计算方法

线性表的第 $ i $ 个元素存放在数组下标为 $ i - 1 $ 的位置

线性表中元素的储存位置之间的关系

$$ LOC(a_{i+1}) = LOC(a_{i}) + c $$

可推得

$$ LOC(a_{i}) = LOC(a_{1}) + (i - 1) * c $$

存取性能为 $ O(1) $ 称之为随机存取结构.

### 3.5 顺序存储结构的插入与删除

#### 3.5.1 获得元素操作

```C
#define OK 1
#define ERROR 0
typedef int status;
status get_elem(const sqList *L, int i, elemType *e)
{
    if (L->length == 0 || i < 1 || i > L->length)
        return ERROR;
    *e = L->data[i - 1];

    return OK;
}
```

#### 3.5.2 插入操作

```c
status list_insert(sqList *L, int i, elemType e)
{
    int k;

    if (L->length == MAXSIZE)
        return ERROR;
    if (i < 1 || i > L->length + 1)
        return ERROR;
    if (i <= L->length) {
        for (k = L->length - 1; k >= i - 1; --k)
            L->data[k + 1] = L->data[k];
    L->data[i - 1] = e;
    ++L->length;

    return OK;
    }
}
```

#### 3.5.3 删除操作

```c
status list_delete(sqList *L, int i, elemType *e)
{
    int k;

    if (L->length == 0)
        return ERROR;
    if (i < 1 || i > L->length + 1)
        return ERROR;
    *e = L->data[i - 1];
    if (i < L->length) {
        for (k = i; k < L->length; ++k)
            L->data[k - 1] = L->data[k];
    }
    --L->length;

    return OK;
}
```

插入和删除操作的时间复杂度分析

最好情况: 插入或者删除最后一个位置时为 $ O(1) $

最坏情况: 插入或者删除第一个位置时为 $ O(n) $

平均情况:

$$
\sum_{i = 1}^{n}\frac{1}{n}(n - i + 1) = \frac{n - 1}{2}
$$

故平均时间复杂度为 $ O(n) $

#### 3.5.4 线性表顺序存储结构的优缺点

- 优点
    - 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
    - 可以快速地存取表中任意位置的元素
- 缺点
    - 插入和删除操作需要移动大量的元素
    - 当线性表长度变化较大时, 难以确定存储空间的容量
    - 造成存储空间的碎片

### 3.6 线性表的链式存储结构

#### 3.6.1 顺序存储结构不足的解决办法

#### 3.6.2 线性表链式存储结构定义

- 结点
    - 数据域
    - 指针域

链式存储结构:
> n个结点链接成一个链表
> 头结点: 有的链表为方便操作, 会在第一个结点前附设一个结点, 头结点数据域内可以不储存任何数据
> 头指针: 无头结点时为链表中第一个结点的存储位置, 有头结点时为指向头结点的指针

#### 3.6.3 线性表链式存储结构代码描述

```c
typedef struct node {
    elemType data;
    struct node *next;
} node;
typedef struct node *linkList;
```

### 3.7 单链表的读取

```c
status get_elem(linkList L, int i, elemType *e)
{
    int j = 1;
    node *p = L->next;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR;
    *e = p->data;
    return OK;
}
```

最坏时间复杂度为 $ O(n) $

### 3.8 单链表的插入与删除

#### 3.8.1 单链表的插入

将结点 `s` 插入到 `p` 与 `p->next` 之间

```c
s->next = p->next;
p->next = s;
```

注意: 上述语句的顺序不可颠倒

```c
status list_insert(linkList *L, int i, elemType e)
{
    int j = 1;
    node *s;
    node *p = *L;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR;
    s = (linkList)malloc(sizeof(node));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}
```

#### 3.8.2 单链表的删除

```c
q = p->next;
p->next = q->next;
free(q);
```

代码如下

```c
status list_delete(linkList *L, int i, elemType *e)
{
    int j = 1;
    node *q;
    node *p = *L;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR;
    q = p->next;
    p->next = q->next;
    *e = q->data;
    free(q);
    return OK;
}
```

插入和删除的时间复杂度均为 $ O(n) $

但若需插入的结点 (或者此结点的前置结点) 的位置已知则时间复杂度为 $ O(1) $

### 3.9 单链表的整表创建

头插法

```c
void create_list_head(linkList *L, int n)
{
    node *p;
    int i;
    *L = (linkList)malloc(sizeof(node));
    (*L)->next = NULL;
    for (i = 0; i < n; ++i) {
        p = (linkList)malloc(sizeof(node));
        p->data = i;
        p->next = (*L)->next;
        (*L)->next = p;
    }
}
```

尾插法

```c
void create_list_tail(linkList *L, int n)
{
    node *p;
    node *r;
    int i;
    *L = (linkList)malloc(sizeof(node));
    r = *L;
    for (i = 0; i < n; ++i) {
        p = (linkList)malloc(sizeof(node));
        p->data = i;
        r->next = p;
        r = p;
    }
    r->next = NULL;
}
```

### 3.10 单链表的整表删除

```c
void clear_list(linkList *L)
{
    node *p, *q;
    p = (*L)->next;
    (*L)->next = NULL;
    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    return OK;
}
```

### 3.11 单链表结构与顺序存储结构的优缺点

### 3.12 静态链表

在早期的没有指针的编程语言中, 用数组描述链表

静态链表结构

```c
#define MAXSIZE 1000
#define HEAD (MAXSIZE - 1)

typedef struct {
    elemType data;
    int cur;
} component, staticLinkList[MAXSIZE];
```

创建静态链表

```c
status init_list(staticLinkList space)
{
    int i;
    for (i = 0; i < HEAD; ++i)
        space[i].cur = i + 1;
    space[HEAD].cur = 0;
    return OK;
}
```

#### 3.12.1 静态链表的插入

分配空闲的结点

```c
int malloc_SSL(staticLinkList space)
{
    int i = space[HEAD].cur;
    if (i)
        space[HEAD].cur = space[i].cur;
    return i;
}
```

静态链表的插入

```c
status list_insert(staticLinkList L, int i, elemType e)
{
    int j, k, l;

    if (i < 1 || i > list_length(L) + 1)
        return ERROR;
    j = malloc_SSL(L);
    if (j) {
        L[j].data = e;
        for (l = 0, k = HEAD; l < i - 1; ++l)
            k = L[k].cur;
        L[j].cur = L[k].cur;
        L[k].cur = j;
        return OK;
    }
}
```

#### 3.12.2 静态链表的删除

释放不使用的结点

```c
void free_SSL(staticLinkList space, int i)
{
    space[i].cur = space[0].cur;
    space[0].cur = i;
}
```

静态链表的删除

```c
status list_delete(staticLinkList L, int i, elemType *e)
{
    int j, k;

    if (i < 1 || i > list_length(L))
        return ERROR;
    for (k = HEAD, j = 0; j < i - 1; ++j)
        k = L[k].cur;
    j = L[k].cur;
    L[k].cur = L[j].cur;
    *e = L[j].data;
    free_SSL(L, j);
    return OK;
}
```

另有其他操作, 如list_length

```c
int list_length(staticLinkList L)
{
    int j = 0;
    int i = L[HEAD].cur;
    while (i) {
        i = L[i].cur;
        ++j;
    }
    return j;
}
```

#### 3.12.3 静态链表的优缺点

### 3.12 循环链表

单循环链表中为使得到最后一节点的时间复杂度为 $ O(1) $ 使用指向终端结点的尾指针 `rear` 代替头指针

查找头结点 `rear->next`

查找开始结点 `rear->next->next`

有头结点的循环链表判断是否为空表

```c
status list_empty(linkList rear) {
    return rear->next == rear;
}
```

合并两个循环链表

```c
void merge_cycle_list(linkList rearA, linkList rearB) {
    node *p, *q;

    p = rearA->next;
    rearA->next = rearB->next->next;
    q = rearB->next;
    rearB->next = p;
    free(q);
}
```

### 3.13 双向链表

在单链表中, 再设置一个指向前驱结点的指针域

```c
typedef struct dulNode {
    elemType data;
    struct dulNode *prior, *next;
} dulNode, dulLinkList;
```

双链表也可设置为循环双链表

有头结点的双链表判断是否为空表

```c
status list_empty(dulLinkList L) {
    return L->next == NULL;
}
```

有头结点的双循环链表判断是否为空表

```c
status list_empty(dulLinkList L) {
    return L->next == L;
}
```

双链表的插入 (s为待插入结点, 插入到p结点之后)

```c
s->prior = p;
s->next = p->next;
p->next->prior = s;
p->next = s;
```

1, 2的顺序可颠倒, 但是其他的顺序不可改变

双链表的删除

```c
p->prior->next = p->next;
p->next->prior = p->prior;
free(p);
```

## 第四章 栈与队列

### 4.2 栈的定义

#### 4.2.1 栈的定义

栈:
> 限定仅在表尾进行插入和删除操作的线性表, 又称为后进先出 (Last In First Out) 线性表, 简称LIFO结构
> 允许进行插入删除操作的一端 (表尾) 称为栈顶 (Top) , 另一端称为栈底 (Bottom)
> 栈的插入操作称为进栈 (Push)
> 栈的删除操作称为出栈 (Pop)

#### 4.2.2 进栈出栈的变化形式

### 4.3 栈的抽象数据类型

```ADT
ADT 栈 (Stack)
Data
    同线性表
Operation
    init_stack(*S)
    destroy_stack(*S)
    clear_stack(*S)
    stack_empty(S)
    get_top(S, *e)
    push(*S, e)
    pop(*S, *e)
    stack_length(S)
endADT
```

### 4.4 栈的顺序存储结构及实现

#### 4.4.1 栈的顺序储存结构

顺序栈:
> 顺序表的简化, 使用下标0的一端作栈底

顺序栈的结构定义

```c
typedef struct {
    elemType data[MAXSIZE];
    int top;
} sqStack;
```

顺序栈的栈空判定

```c
status stack_empty(const sqStack *S)
{
    if (S->top == -1) {
        return OK;
    } else {
        return ERROR;
    }
}
```

#### 4.4.2 进栈操作

顺序栈的进栈

```c
status push(sqStack *S, elemType e)
{
    if (S->top == MAXSIZE - 1) {
        return ERROR;
    }
    S->top++;
    S->data[S->top] = e;
    return OK;
}
```

#### 4.4.3 出栈操作

顺序栈的出栈

```c
status pop(sqStack *S, elemType *e)
{
    if (S->top == -1) {
        return ERROR;
    }
    *e = S->data[S->top];
    S->top--;
    return OK;
}
```

出栈入栈时间复杂度均为 $ O(1) $

### 4.5 两栈共享空间

### 4.6 栈的链式存储结构及实现

#### 4.6.1 栈的链式存储结构

链栈:
> 链表的简化, 表头作栈顶, 且一般不需要头结点

链栈的结构定义

```c
typedef struct node {
    elemType data;
    struct node *next;
} node, *linkStackPtr;

typedef struct {
    linkStackPtr top;
    int count;
} linkStack;
```

链栈的栈空判定

```c
status stack_empty(linkStack *S)
{
    if (S->top == NULL) {
        return OK;
    } else {
        return ERROR;
    }
}
```

#### 4.6.2 进栈操作

链栈的进栈

```c
status push(linkStack *S, elemType e)
{
    node *s = (node*)malloc(sizeof(node));

    s->data = e;
    s->next = S->top;
    S->top = s;
    S->count++;
    return OK;
}
```

#### 4.6.3 出栈操作

链栈的出栈

```c
status pop(linkStack *S, elemType *e)
{
    node *p = S->top;

    if (S->top == NULL) {
        return ERROR;
    }
    *e = p->data;
    S->top = p->next;
    free(p);
    S->count--;
    return OK;
}
```

出栈入栈时间复杂度均为 $ O(1) $

### 4.7 栈的作用

栈的引入简化了程序设计的问题, 划分了不同关注层次, 使得思考范围缩小, 更加聚焦于要解决的问题核心.

### 4.8 栈的应用--递归

#### 4.8.1 斐波那契数列的实现

迭代法

```c
int fibonacci_iter(int n)
{
    int i;
    int fibo[100];
    fibo[0] = 0;
    fibo[1] = 1;
    for (i = 2; i <= n; ++i) {
        fibo[i] = fibo[i - 1] + fibo[i - 2];
    }
    return fibo[n];
}
```

递归法

```c
int fibonacci_recu(int n)
{
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci_recu(n - 1) + fibonacci_recu(n - 2);
    }
}
```

#### 4.8.2 递归的定义

递归函数:
> 直接调用自己或者经过一系列调用语句间接调用自己的函数

递归过程中先进行前行的递归调用, 随后又以前行顺序的逆序进行退回, 退回过程中可能需要恢复前行过程中的某些数据以执行某些动作, 故编译器使用栈实现递归

在前行阶段, 每一层递归对应的函数的局部变量, 参数值, 返回地址都被压入栈中, 回退阶段依次弹出进行恢复

### 4.9 栈的应用--四则运算表达式求值

#### 4.9.1 后缀 (逆波兰) 表示法的定义

后缀表示法:
> 符号在要运算的数字后出现, 不需要使用括号和优先级限定运算顺序
> 对应的, 传统的标准四则运算表达式称为中缀表达式

#### 4.9.2 后缀表达式的计算结果

运算方法:

```Pseudocode
从左到右遍历后缀表达式,

    遇到数字则进栈;

    遇到运算符则将栈顶的两个数字弹栈, 第一个出栈的位于运算符右侧, 第二个出栈的位于运算符左侧, 完成相应运算后计算结果进栈,

直至遍历完成, 将最终结果弹栈.
```

#### 4.9.3 中缀表达式转后缀表达式

转换方法:

```pesudocode
从左到右遍历中缀表达式,

    遇到数字则输出;

    遇到左括号则进栈;

    遇到右括号则将栈中运算符依次出栈并输出, 直至遇到左括号将其仅出栈不输出;

    遇到运算符则判断其与栈顶运算符的优先级,

        如果为空栈或栈顶为左括号( 则直接入栈;

        如果当前运算符优先级高于栈顶运算符则当前运算符入栈;

        如果当前运算符优先级不高于 (<=) 栈顶运算符, 则将栈中元素出栈并输出, 继续将当前运算符同栈顶运算符进行下一次比较;

继续遍历中缀表达式, 最终遍历完成中缀表达式, 将剩余栈中运算符依次弹栈输出, 完成转化
```

运算符等级 (从高到低) :

\* /

\+ \-

### 4.10 队列的定义

队列:
> 限定仅在表尾进行插入, 仅在表头进行删除操作的线性表, 又称为先进先出 (First In First Out) 线性表, 简称FIFO结构
> 允许进行插入操作的一端 \(表尾\) 称为队尾, 允许进行删除操作的一端 \(表头\) 称为队头
> 队列的插入操作称为入队, 删除操作称为出队

### 4.11 队列的抽象数据类型

```ADT
ADT 队列 (Queue)
Data
    同线性表
Operation
    init_queue(*Q)
    destroy_queue(*Q)
    clear_queue(*Q)
    queue_empty(Q)
    get_head(Q, *e)
    enqueue(*Q, e)
    dequeue(*Q, *e)
    queue_length(Q)
endADT
```

### 4.12 循环队列

#### 4.12.1 队列顺序存储的不足

#### 4.12.2 循环队列的定义

`front`指向队头元素, `rear`指向队尾元素的下一个位置

队满条件 (使用`flag`, 使最大储存量为`MAXSIZE`):
` (rear + 1) % queueSize == front && flag == 1 `

队满条件 (不使用`flag`, 使最大储存量为`MAXSIZE - 1`):
` (rear + 1) % queueSize == front `

主要采用不使用`flag`的版本

队列长度:
` (rear - front + queueSize) % queueSize `

顺序存储结构代码:

```c
typedef struct {
    elemType data[MAXSIZE];
    int front;
    int rear;
} sqQueue;
```

初始化循环队列:

```c
status init_queue(sqQueue *Q)
{
    Q->front = 0;
    Q->rear = 0;
    return OK;
}
```

循环队列判空:

```c
int queue_empty(const sqQueue *Q)
{
    return Q->front == Q->rear;
}
```

循环队列判满:

```c
int queue_full(const sqQueue *Q)
{
    return (Q->rear + 1) % MAXSIZE == Q->front;
}
```

循环队列长度:

```c
int queue_length(const sqQueue *Q)
{
    return (Q->rear - Q->front + MAXSIZE) % MAXSIZE;
}
```

循环队列入列:

```c
status enqueue(sqQueue *Q, elemType e)
{
    if ((Q->rear + 1) % MAXSIZE == Q->front) {
        return ERROR;
    }
    Q->data[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXSIZE;
    return OK;
}
```

循环队列出列:

```c
status dequeue(sqQueue *Q, elemType *e)
{
    if (Q->front == Q->rear) {
        return ERROR;
    }
    *e = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;

    return OK;
}
```

出队入队时间复杂度均为 $ O(1) $

### 4.13 队列的链式存储结构及实现

链队列:
> 链表的简化, 且一般需要头结点, 头节点的 `next` 指针指向队头
> 空队列时, `front` 和 `rear` 均指向头结点

链队列的结构定义:

```c
typedef struct node {
    elemType data;
    struct node *next;
} node;
typedef node *queuePtr;

typedef struct {
    queuePtr front;
    queuePtr rear;
} linkQueue;
```

#### 4.13.1 入队操作

链队列的入队:

```c
status enqueue(linkQueue *Q, elemType e)
{
    queuePtr p = (queuePtr)malloc(sizeof(node));
    if (!p) {
        exit(OVERFLOW);
    }
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = p;
    return OK;
}
```

#### 4.13.2 出队操作

链队列的出队:

```c
status dequeue(linkQueue *Q, elemType *e)
{
    queuePtr p;
    if (Q->front == Q->rear) {
        return ERROR;
    }
    p = Q->front->next;
    *e = p->data;
    Q->front->next = p->next;
    if (Q->rear == p) {
        Q->rear = Q->front;
    }
    free(p);
    return OK;
}
```

## 第五章 串

### 5.2 串的定义

串:
> 由零个或多个字符组成的有限序列, 又叫字符串

空串:

子串与主串:

子串在主串中的位置:

### 5.3 串的比较

字符比较:
> 比较两字符的编码值 (ASCII, Unicode)

串相等:
> 串的长度和各个位置对应的字符都相等

串大小判断 (字典序) :

逐个比较两串 $ s $ 与 $ t $ 各个位置字符的大小, 当出现不同时, 字符小的对应的串小, 若直至某一串被遍历完未发现字符不同, 被遍历完成的串小 (长度短的字符串小), 都被遍历完成则两串相等

### 5.4 串的抽象数据类型

串的逻辑结构同线性表相似, 但所含元素和主要操作不同

```ADT
ADT 串 (string)
Data
    串中元素仅由字符组成, 相邻元素具有前驱和后继关系
Operation
    str_assign(*T, *chars)
    str_copy(*T, S)
    str_length(S)
    str_compare(S, T)
    str_concat(*T, S1, S2)
    sub_string(*Sub, S, pos, len)
    str_insert(*T, pos, S)
    str_delete(*T, pos, len)
    str_replace(*T, S, V)
    str_index(S, T, pos)
    clear_string(*S)
endADT
```

`str_index` 操作的实现

```c
int str_index(string S, string T, int pos)
{
    int n, m, i;
    string sub;

    if (pos > 0) {
        n = str_length(S);
        m = str_length(T);
        i = pos;
        while (i <= n - m + 1) {
            sub_string(sub, S, i, m);
            strncpy(sub, S + i - 1, m);
            if (str_compare(sub, T) != 0) {
                ++i;
            } else {
                return i;
            }
        }
    }

    return 0;
}
```

### 5.5 串的存储结构

#### 5.5.1 串的顺序存储结构

> 用一组地址连续的储存单元存储串中的字符序列

表示串长的方法:

1. 下标0处存串长, 字符从下标1处开始 (本书采用的方法)
2. 字符从下标0处开始, 在字符的末尾存储一 `"\0"` 表示字符串结束 (C语言采用的方法)

#### 5.5.2 串的链式存储结构

> 与链表相同, 但可以考虑每个结点内存放多个字符, 未占满的结点内用 `"\0"` 或其他字符补全

### 5.6 朴素的模式匹配算法

串的模式匹配:
> 定位子串的位置的操作, 子串又称模式串

只使用基本的数组操作完成 `str_index`, 假定串长存储于下标为0的位置中

```c
int str_index(string S, string T, int pos)
{
    int i = pos;
    int j = 1;

    while (i <= S[0] && j <= T[0]) {
        if (S[i] == T[j]) {
            ++i;
            ++j;
        } else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > T[0]) {
        return i - T[0];
    } else {
        return 0;
    }
}
```

对于C语言中的字符串, 最后一位为 `"\0"` , 对应的 `str_index` 算法

```c
int str_index_c(string S, string T, int pos)
{
    int i = pos;
    int j = 0;
    int len_T;

    while (T[++j] != '\0');
    len_T = j;
    while (S[i] != '\0' && T[j] != '\0') {
        if (S[i] == T[j]) {
            ++i;
            ++j;
        } else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (T[j] == '\0') {
        return i - len_T;
    } else {
        return 0;
    }
}
```

### 5.7 KMP模式匹配算法

#### 5.7.1 KMP模式匹配算法的原理

在查找前对子串进行分析达到如下的目的:

1. 通过子串中相等或不同的字符使得指向主串的游标 `i` 不需要回溯

2. 指向子串的游标 `j` 的变化则取决于 `j` 指向的子串当前字符之前的串的前后缀的相似程度, 使得部分情况下 `j` 的回溯减少

把子串 `T` 的各个位置 `j` 值对应的变化记为定义为数组 `next`, `next` 的长度与 `T` 串相同, 得到如下的函数定义
$$
next[j] = \begin{cases}
0, & j = 1 \\
MAX\{k | 1 \leq k < j, T_1T_2\cdots T_{k-1} = T_{j-k}T_{j-k+1}\cdots T_{j-1}\}, & \text{When the set is not empty} \\
1, & others
\end{cases}
$$

#### 5.7.2 `next` 数组值的推导

1. 令` next[1] = 0 `, ` next[2] = 1 `
2. 随后的各个字符计算当前字符之前的串的最大相同前后缀长度为 `n` , `next[j] = n + 1` , 如  `"ab"`为1, ` "abca" ` 为2, ` "ababa" ` 为4

#### 5.7.3 KMP模式匹配算法的实现

编码计算 `next` 数组

对于模式串的位置 `j + 1`, 有以下两种情况:
若 `p[k] == p[j]`, 则有 `next[j + 1] = next[j] + 1`;
若 `p[k] != p[j]`, 则令 `k = next[k]`, 若 `p[k] == p[j]`, `next[j + 1] = k + 1`, 否则重复此过程。

```c
void get_next(string T, int next[])
{
    int i, k;
    i = 1;          /* As the index of the next areray */
    k = 0;
    next[1] = 0;    /* begin of next is 0 */
    while (i < T[0]) {
        if (k == 0 || T[i] == T[k]) {
            ++i;
            ++k;
            next[i] = k;
        } else {
            k = next[k];
        }
    }
}
```

实现KMP算法

```c
int str_index_KMP(string S, string T, int pos)
{
    int i = pos;
    int j = 1;
    int next[255];

    get_next(T, next);
    while (i <= S[0] && j <= T[0]) {
        if (S[i] == T[j]) {
            ++i;
            ++j;
        } else {
            j = next[j];    /* Only change this line compare with str_index */
        }
    }
    if (j > T[0]) {
        return i - T[0];
    } else {
        return 0;
    }
}
```

若  `S` 的长度为 $n$, `T` 的长度为 $m$

`get_next`函数的时间复杂度为 $ O(m) $

` str_index_KMP `的 `while` 部分的时间复杂度为 $ O(n) $

总的时间复杂度为 $ O(n + m) $

#### 5.7.4 KMP模式匹配算法的改进

利用模式串内的相同字符, 进一步减少回溯次数

在 `get_next` 函数中, 若 `T[j] == T[next[j]]`, 则 `next[j] = next[next[j]]`

计算 `nextval` 数组

```c
void get_nextval(string T, int nextval[])
{
    int i, k;
    i = 1;          /* As the index of the next areray */
    k = 0;
    nextval[1] = 0; /* begin of next is 0 */
    while (i < T[0]) {
        if (k == 0 || T[i] == T[k]) {
            ++i;
            ++k;
            if (T[i] != T[k]) {
                nextval[i] = k;
            } else {
                nextval[i] = nextval[k];
            }
        } else {
            k = nextval[k];
        }
    }
}
```

如果需要进行查找, 将查找函数中的 `get_next` 替换为 `get_nextval` 即可

#### 5.7.5 nextval 数组值的推导

步骤:

先计算 `next` 数组, 随后从 `i = 1` 开始计算 `nextval` 数组

令模式串中 `i` 位置指向的字符 `T[i]` 为 $a$, `next[i]` 位置指向的字符 `T[next[i]]` 为 $b$

$a$ 的值与 $b$ 的值不同, 则 `nextval[i]` 为 `next[i]` 保持不变, 否则 `nextval[i]` 的值改为 $b$ 对应的 `nextval` 的值

即若 `T[i] != T[next[i]]`, 则 `nextval[i] = next[i]`, 否则 `nextval[i] = nextval[next[i]]`

## 第六章 树

### 6.2 树的定义

树:

> $ n ( n \ge 0 ) $ 个结点的有限集
>
> $ n = 0 $ 时称为空树
>
> 在任意一棵非空树中:
>
> 1. 有且仅有一个特定的称为根 (Root) 的结点
> 2. $ n > 1 $  时, 其余节点可分为 $ m (m > 0) $ 个互不相交的有限集 $ T_1, T_2, \cdots, T_n $ 其中每一个集合本身又是一棵树, 称为根的子树 (subtree)

注意:

1. $ n > 0 $ 时的根节点唯一
2. $ m > 0 $ 时, 子树的个数没有限制, 但一定互不相交

#### 6.2.1 结点的分类

结点由一个数据元素和若干指向其子树的分支组成

结点的度 (degree): 结点拥有的子树数

度为 0 的结点称为叶节点 (leaf) 或者终端结点

度不为 0 的结点称为非叶节点或者分支结点, 除根以外的分支结点又称内部节点

记度数为 $ n $ 的结点个数为 $ n_n $ 则一棵树中的结点满足如下关系
$$
\sum^{n}_{i = 1} i n_{i} + 1 = \sum^{n}_{i = 0} n_i
$$

树的度: 树内各结点的度的最大值

#### 6.2.2 结点间的关系

结点的子树的根称为结点的孩子 (child)

相反该结点称为其孩子的双亲 (parent) , 也称父结点

同一个双亲的孩子之间互称兄弟 (sibling)

结点的祖先是从该结点所经分支上所有的结点

一某结点为根的子树中的任一结点都称为其子孙

### 6.3 树的抽象数据类型

```ADT
ADT 树 (Tree)
Data
    树是由一个根节点和若干棵子树构成. 树中结点具有相同数据类型及层次关系
Operation
    init_tree(*T)
    destroy_tree(*T)
    create_tree(*T, definition)
    clear_tree(*T)
    tree_empty(T)
    tree_depth(T)
    root(T)
    value(T, cur_e)
    assign(T, cur_e, value)
    parent(T, cur_e)
    left_child(T, cur_e)
    right_sibling(T, cur_e)
    insert_child(*T, *p, i, c)
    delete_child(*T, *p, i)
    traverse_tree(T, visit())
endADT
```

### 6.4 树的存储结构

#### 6.4.1 双亲表示法

以一组连续空间存储树的结点, 在每个结点中附设一个指示器指示其双亲结点在数组中的位置, 故结点分为数据域和双亲域

```c
#define MAXSIZE 100

typedef struct PTNode {
    elemType data;
    int parent;
} PTNode;

typedef struct {
    PTNode nodes[MAXSIZE];
    int r;      /* index of root */
    int n;      /* number of nodes */
} PTree;
```

从节点计算其双亲结点的复杂度为 $ O(1) $, 但计算孩子结点需要遍历整个结构

为方便计算某结点的孩子结点可以选择增设长子域和右兄弟域

```c
/* enhanced PTree */
typedef struct PTNode {
    elemType data;
    int parent;
    int firstChild; /* choice */
    int rightSib;   /* choice */
} ePTNode;

typedef struct {
    ePTNode nodes[MAXSIZE];
    int r;      /* index of root */
    int n;      /* number of nodes */
} ePTree;
```

#### 6.4.2 孩子表示法

多重链表表示法

每个结点有多个指针域, 每个指针指向一棵子树的根节点

可选择的方案:

- 指针域的个数等于树的度
    缺点: 各结点度相差较大时浪费空间

- 每个结点的指针域等于其度, 并设一变量储存结点的度

    各个结点结构不同, 且要维护度数, 造成性能损耗

实际的方案*孩子表示法*:

将每个结点的孩子结点排列成单链表, 则 $ n $ 个结点即有 $ n $ 个单链表, 叶子结点的单链表为空, 随后将 $ n $ 个头结点组成顺序表

需要两个数据结构

1. 排成单链表的孩子结点
2. 组成表头数组的表头结点

```c
#define MAXSIZE 100

typedef struct cNode { /* child tree node */
    elemType data;
    struct cNode *next;
} cNode, *childPtr;

typedef struct {        /* head node */
    elemType data;
    childPtr firstChild;
}hBox;

typedef struct {
    hBox nodes[MAXSIZE];
    int r;      /* index of root */
    int n;      /* number of nodes */
} cTree;
```

孩子表示法可以较快查得结点的孩子, 但是查找结点双亲困难

可以在顺序表内增设双亲域加快寻找结点双亲的过程, 称为双亲孩子表示法

#### 6.4.3 孩子兄弟表示法

设有两个指针域, 指向结点的第一个孩子以及结点的右兄弟

```c
typedef struct csNode {
    elemType data;
    struct csNode *firstChild;
    struct csNode *rightSib;
} csNode, *csTree;
```

可以通过此方法将任何树简化为后文将讲的二叉树进行分析

### 6.5 二叉树的定义

二叉树:

> $ n ( n \ge 0 ) $ 个结点的有限集, 该集合或者为空集 (称为空二叉树), 或者由一个根节点和两棵互不相交的, 分别称为根节点的左子树和右子树的二叉树组成

#### 6.5.1 二叉树的特点

1. 每个结点最多有两棵子树, 故二叉树中不存在度大于 2 的结点, 二叉树的度最大为2
2. 左子树和右子树是有顺序的, 不可颠倒
3. 即使某结点仅有一棵子树, 也必须区分左子树和右子树

#### 6.5.2 特殊二叉树

##### 1. 斜树

所有结点都只有左子树的二叉树称左斜树; 所有结点都只有右子树的二叉树称右斜树; 二者统称为斜树

##### 2. 满二叉树

二叉树中, 所有分支结点都有左子树和右子树, 并且所有的叶子结点都在同一层上

满二叉树的特点:

1. 叶子结点都出现在最后一层
2. 非叶子节点的度必定为2
3. 同样深度的二叉树中, 满二叉树的结点个数最多, 叶子结点的个数也最多

##### 3. 完全二叉树

把一棵具有 $ n $ 个结点的二叉树按层序编号, 若编号为 $ i ( 1 \le i \le n) $ 的结点与同样深度的二叉树中编号为 $ i $ 的结点在二叉树中位置完全相同, 则称此二叉树为完全二叉树

完全二叉树的特点:

1. 叶子结点都出现在最下两层
2. 最下层的叶子结点集中在左部连续位置
3. 倒数第二层若存在叶子结点则全部出现于倒数第二层的最右侧位置
4. 若某结点的度为1, 则其必位于倒数第二层, 且必只有左子树
5. 同样结点数的二叉树, 完全二叉树的深度最小

### 6.6 二叉树的性质

#### 性质1

在二叉树的第 $ i $ 层至多有 $ 2^{i - 1} $ 个结点 $ (i \ge 1) $

#### 性质2

深度为 $ k $ 的二叉树最多有 $ 2^{k} - 1 $ 个结点 $ (k \ge 1) $

#### 性质3

对任意一棵二叉树 T, 如果其终端结点数为 $ n_0 $, 度为2的结点数为 $ n_2 $, 则 $ n_0 = n_2 + 1 $

#### 性质4

具有 $ n $ 个结点的完全二叉树的深度为 $ \left \lfloor \log_2n \right \rfloor + 1$, 也可记为 $ \left \lceil \log_2{n + 1} \right \rceil $

推导:

深度为 $ k $ 的满二叉树的结点数为 $ 2^{k} - 1 $, 反推得 $ n = 2^{k} - 1 $ 个结点的满二叉树深度为 $ k = \log_2(n+1) $

则对于同样深度的完全二叉树, 其结点数大小必定小于或等于同样深度的满二叉树, 但必定比小一深度的满二叉树大, 故有 $ 2^{k-1} - 1 < n \le 2^{k} - 1 $ 移项后取对数有 $ k - 1 < \log_2(n + 1) \le k $ 即由深度 $ k $ 为整数得 $ k = \left \lceil \log_2{n + 1} \right \rceil $

又由于 $ n $ 是整数, 故可改写为 $ 2^{k-1} \le n < 2^{k} $ 取对数得 $ k - 1 \le \log_{2}{n} < k $ 即由深度 $ k $ 为整数得 $ k = \left \lfloor \log_2n \right \rfloor + 1 $

#### 性质5

如果对一棵有 $ n $ 个结点的完全二叉树 (深度为 $ \left \lfloor \log_2n \right \rfloor + 1$) 的结点按层编序 (从第一层到最后一层, 从左到右), 对任一结点 $ j (1 \le j \le n)$有

1. 如果 $ i=1$ 则结点 $ i $ 是二叉树的根, 无双亲; 如果 $ i > 1 $ 则其双亲结点为 $ \left \lfloor {i}/{2} \right \rfloor $
2. 如果 $ 2i > n $ 则结点 $ i $ 无左孩子 (结点 $ i $为叶子结点), 否则其左孩子为 $ 2i $
3. 如果 $ 2i + 1 > n $ 则结点 $ i $ 无右孩子, 否则其右孩子为 $ 2i + 1 $

### 6.7 二叉树的储存结构

#### 6.7.1 二叉树的顺序存储结构

二叉树的顺序存储结构:
> 用一维数组储存二叉树的结点, 将一棵树按完全二叉树编号, 存入对应的下标中, 不存在的结点标记为空
> 由于一般的二叉树可能浪费大量空间, 故一般用于完全二叉树

#### 6.7.2 二叉链表

结点内有一个数据域, 两个指针域, 分别指向左右孩子

```c
typedef struct BiTNode {
    elemType data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;
```

可根据需要增设如指向其双亲的指针等指针域, 增加查找速度

### 6.8 遍历二叉树

#### 6.8.1 二叉树的遍历原理

二叉树的遍历:
> 从根结点出发, 按照某种次序依次访问二叉树中所有结点, 使得每个结点被访问一次, 且仅被访问一次

#### 6.8.2 二叉树的遍历方法

##### 1 前序遍历

> 若二叉树为空, 则空操作返回; 否则先访问根结点, 再前序遍历左子树, 最后前序遍历右子树

##### 2 中序遍历

> 若二叉树为空, 则空操作返回; 否则从根结点开始, 中序遍历左子树, 访问根结点, 最后中序遍历右子树

##### 3 后序遍历

> 若二叉树为空, 则空操作返回; 否则从根结点开始, 后序遍历左子树, 后序遍历右子树, 最后访问根结点

##### 4 层序遍历

> 若二叉树为空, 则空操作返回; 否则从树的第一层即根结点开始, 从上到下逐层遍历, 在同一层内, 从左到右遍历

#### 6.8.3 前序遍历的递归算法

```c
/* PreOrder Traversal */
void PreOrder(BiTree T)
{
    if (T != NULL) {
        printf("%d ", T->data);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}
```

#### 6.8.4 中序遍历的递归算法

```c
/* InOrder Traversal */
void InOrder(BiTree T)
{
    if (T != NULL) {
        InOrder(T->lchild);
        printf("%d ", T->data);
        InOrder(T->rchild);
    }
}
```

#### 6.8.5 后序遍历的递归算法

```c
/* PostOrder Traversal */
void PostOrder(BiTree T)
{
    if (T != NULL) {
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        printf("%d ", T->data);
    }
}
```

#### 6.8.6 推导遍历结果

### 6.9 二叉树的建立

```c
/* Create a binary tree */
void CreateBiTree(BiTree *T)
{
    elemType ch;
    scanf("%c", &ch);
    if (ch == '#') {
        *T = NULL;
    } else {
        *T = (BiTree)malloc(sizeof(BiTNode));
        if (!*T) {
            exit(OVERFLOW);
        }
        (*T)->data = ch;
        CreateBiTree(&(*T)->lchild);
        CreateBiTree(&(*T)->rchild);
    }
}
```

### 6.10 线索二叉树

#### 6.10.1 线索二叉树的原理

为利用二叉链表中的空指针域, 使其指向前驱或后继结点, 从而提高遍历效率

> 线索: 指向前驱或后继的指针
> 线索链表: 加上线索的二叉链表
> 线索二叉树: 线索链表对应的二叉树
> 线索化: 对二叉树以某种次序遍历使其变为线索二叉树的过程

线索二叉树可以达到将一棵二叉树转化为双向链表的目的

为区分指针域指向孩子还是前驱后继, 需要增设标志位 `ltag` 和 `rtag`

对于 `lchild` 指针: 若 `ltag = 0` 则指向左孩子, 若 `ltag = 1` 则指向前驱

对于 `rchild` 指针: 若 `rtag = 0` 则指向右孩子, 若 `rtag = 1` 则指向后继

#### 6.10.2 线索二叉树结构的实现

实现代码如下

```c
typedef enum {link, thread} pointerTag;

typedef struct biThrNode {
    elemType data;
    struct biThrNode *lchild, *rchild;
    pointerTag ltag, rtag;
} biThrNode, *biThrTree;
```

#### 6.10.3 线索二叉树的线索化

线索化的过程即遍历二叉树的过程, 在遍历的过程中, 将空指针域指向前驱或后继

中序线索化的过程如下

```c
biThrTree pre = NULL;
void InThreading(biThrTree p)
{
    if (p) {
        InThreading(p->lchild);
        if (!p->lchild) {
            p->ltag = thread;
            p->lchild = pre;
        }
        if (!pre->rchild) {
            pre->rtag = thread;
            pre->rchild = p;
        }
        pre = p;
        InThreading(p->rchild);
    }
}
```

有了线索二叉树后, 进行相应的遍历即为操作一双向链表的过程

可以选择增加一头结点令其 `lchild` 指向线索二叉树的root结点, `rchild` 指向遍历时访问的最后一个结点,与此同时, 使遍历时的第一个结点的 `lchild` 最后一个结点的 `rchild` 均指向该头结点, 方便从第一个结点进行顺后驱遍历或者从最后一个结点进行顺前驱遍历

遍历的代码如下

```c
status inOrderTraverse_Thr(biThrTree T)
{
    biThrTree p;
    p = T->lchild;
    while (p != T) {
        while (p->ltag == link) {
            p = p->lchild;
        }
        printf("%c ", p->data);
        while (p->rtag == thread && p->rchild != T) {
            p = p->rchild;
            printf("%c ", p->data);
        }
        p = p->rchild;
    }
    return OK;
}
```

本质上为链表的扫描, 故复杂度为 $ O(n) $

### 6.11 树、森林与二叉树的转换

#### 6.11.1 树转换为二叉树

将树转换为二叉树的过程为:

1. 加线: 在所有的兄弟结点之间加一条线
2. 去线: 对树中每个结点, 只保留它与第一个孩子结点之间的连线, 去掉它与其它孩子结点之间的连线
3. 层次调整: 以树的根结点为二叉树的根, 其它结点进行相应的层次调整, 注意结点的第一个孩子是二叉树结点的左孩子, 其兄弟是二叉树结点的右孩子

#### 6.11.2 森林转换为二叉树

将森林转换为二叉树的过程为:

1. 将森林中每棵树转换为二叉树
2. 从第二棵树开始, 依次把后一棵树的根节点作为前一棵树的根节点的右孩子, 直到整个森林转换为一棵二叉树

#### 6.11.3 二叉树转换为树

将二叉树转换为树的过程为:

1. 加线: 若某结点的左孩子存在, 则将此左孩子的右孩子以及此右孩子后的 $ n $ 个右孩子都作为此左孩子的兄弟, 即初始结点的孩子
2. 去线: 删除所有结点与其右孩子之间的连线
3. 层次调整

#### 6.11.4 二叉树转换为森林

将二叉树转换为森林的过程为:

1. 从根节点开始, 若右孩子存在, 则将其与右孩子之间的连线删除, 随后处理被分离的右孩子, 直至右孩子不存在, 从而将所有树分离
2. 将分离后的二叉树转换为树

#### 6.11.5 树与森林的遍历

##### 树的遍历方式

1. 先根遍历: 先访问根结点, 再依次先根遍历每棵子树 (对应二叉树的前序遍历, 与其转换为二叉树后的前序遍历结果相同)
2. 后根遍历: 先依次后根遍历每棵子树, 再访问根结点 (对应二叉树的后序遍历, 与其转换为二叉树后的中序遍历结果相同)

##### 森林的遍历方式

1. 先序遍历: 先对第一棵树进行先根遍历, 随后以同样的方式遍历除去第一棵树组成的森林 (与其转换为二叉树后的前序遍历结果相同)
2. 后序遍历: 先对第一棵树进行后根遍历, 随后以同样的方式遍历除去第一棵树组成的森林 (与其转换为二叉树后的中序遍历结果相同)

### 6.12 哈夫曼树及其应用 (树的应用)

#### 6.12.2 哈夫曼树的定义和原理

> 带权二叉树: 二叉树中的结点 (一般为叶子节点) 带有权值
> 路径长度: 从根结点到第 $ i $ 个叶子结点的路径上的分支结点个数
> 树的路径长度: 树中所有结点的路径长度之和
> 结点的带权路径长度: 从根结点到该结点的路径长度与该结点的权值的乘积
> 树的带权路径长度: 树中所有叶子结点的带权路径长度之和
> 哈夫曼树: 给定 $ n $ 个带权叶子节点, 构造出的带权路径长度 (WPL) 最小的二叉树, 也称最优二叉树

哈夫曼树的构造过程:

1. 将 $ n $ 个结点按照权值从小到大排序
2. 取出权值最小的两个结点 (或者树), 构造一棵新的二叉树, 其根结点 $ N_1 $的权值为这两个结点的权值之和, 左孩子为较小的结点, 右孩子为较大的结点, 随后以 $ N_1 $ 为根结点的树视为一个结点插入到原序列中并保持从小到大的顺序
3. 重复上一步骤, 直至所有结点构造为一棵二叉树

#### 6.12.3 哈夫曼编码

> 前缀编码: 若要设计长短不等的编码, 则必须保证任何一个编码都不是另一个编码的前缀
> 哈夫曼编码: 一种变长编码, 由于哈夫曼树的特性, 可以保证任意字符的编码不是另一个字符的前缀, 从而可以实现无歧义的解码

哈夫曼编码的过程:

1. 将需要编码的字符按照某种权值构造哈夫曼树
2. 向左走为 0, 向右走为 1, 从根结点到叶子结点的路径即为该字符的编码

解码过程:
根据进行哈夫曼编码的哈夫曼树, 从根结点开始, 依次根据编码的 0 或 1 向左或向右走, 直至走到叶子结点, 则得到对应的字符
